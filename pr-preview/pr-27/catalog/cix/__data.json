{"type":"data","nodes":[null,{"type":"data","data":[{"extension":1},{"slug":2,"kind":3,"manifest":4,"tagline":9,"readme":10,"components":11,"variant":13,"tags":14,"docs":16,"docCount":28},"cix","tool",{"name":2,"version":5,"description":6,"author":7},"0.1.0","Package manager for cognitive extensions. Discovers, installs, and manages Claude Code extensions from marketplace repositories.",{"name":8},"Mox Labs","Discover, install, and manage cognitive extensions that enhance rather than replace human capability.","# cix - Collaborative Intelligence Extensions CLI\n\n> Discover, install, and manage cognitive extensions that enhance rather than replace human capability.\n\n## Philosophy\n\ncix is built on the **Collaborative Intelligence** thesis: AI tools should amplify human capability, not substitute for it. Every extension in this ecosystem is designed to make you more capable, not dependent.\n\n## Installation\n\n```bash\nuv tool install cix\n```\n\n## Quick Start\n\n```bash\n# Add a source (marketplace of extensions)\ncix source add https://github.com/mox-nexus/cix-extensions\n\n# List available extensions\ncix list -a\n\n# Install an extension\ncix add reasoning-frameworks\n\n# See what's installed\ncix list\n```\n\n## Commands\n\n### Sources (Extension Marketplaces)\n\n```bash\ncix source add \u003Curl>        # Register a source\ncix source list             # Show registered sources\ncix source rm \u003Cname>        # Remove a source\ncix source refresh [name]   # Fetch latest from source(s)\n```\n\n### Extensions\n\n```bash\ncix list [-a] [-v]          # List installed (or -a available) extensions\ncix add \u003Cextension>         # Install an extension\ncix rm \u003Cextension>          # Remove an extension\ncix update [extension]      # Update extension(s)\ncix show \u003Cextension>        # Show extension details\n```\n\n### System\n\n```bash\ncix info                    # Show cix configuration and status\n```\n\n## Extension Types\n\n| Type | Purpose | Example |\n|------|---------|---------|\n| **Skill** | Decision frameworks and methodology | reasoning-patterns |\n| **Agent** | Specialized subagents for delegation | structured-problem-solver |\n| **Hook** | Event-triggered behaviors | metacognitive-check |\n| **MCP** | External service integrations | knowledge-base-connector |\n\n## Design Principles\n\n1. **Complementary, not Substitutive** - Extensions enhance your capability, they don't replace it\n2. **Transparent Reasoning** - See why, not just what\n3. **Human-Initiated** - You control when and how extensions engage\n4. **Evidence-Based** - Claims are grounded in research and experience\n\n## License\n\nMIT\n",{"agents":12,"skills":12,"hooks":12,"commands":12},0,"spark",[3,15],"cli",{"explanation":17,"how-to":26,"tutorials":27},[18,22],{"slug":19,"title":20,"content":21},"methodology","cix: Methodology","# cix: Methodology\n\nWhy a package manager for cognitive extensions exists and how it's designed.\n\n---\n\n## Contents\n\n- [The Problem](#the-problem)\n- [Why a Package Manager](#why-a-package-manager)\n- [When Manual Management Breaks](#when-manual-management-breaks)\n- [The Marketplace Model](#the-marketplace-model)\n- [Design Decisions](#design-decisions)\n- [Hexagonal Architecture](#hexagonal-architecture)\n- [Extension Types](#extension-types)\n- [Scope Boundaries](#scope-boundaries)\n\n---\n\n## The Problem\n\nClaude Code extensions (skills, agents, hooks, MCP servers) are files in directories. Installing one means copying the right files to `~/.claude/plugins/`. Discovering what's available means browsing repositories manually. Updating means re-downloading and overwriting.\n\nThis is manageable for one or two extensions. At ecosystem scale, it becomes the same problem every language ecosystem solved decades ago:\n\n| Language | Solution | Year |\n|----------|----------|------|\n| Perl | CPAN | 1995 |\n| Python | pip/PyPI | 2008 |\n| Node | npm | 2010 |\n| Rust | cargo/crates.io | 2014 |\n\ncix is the package manager for Claude Code extensions. It solves discovery, installation, updates, and removal.\n\n---\n\n## Why a Package Manager\n\nManual extension management has compounding costs:\n\n**Discovery**: How does a user find extensions that match their workflow? Browsing GitHub repos doesn't scale. A curated, searchable catalog does.\n\n**Installation**: Copying files is error-prone. Wrong directory structure, missing dependencies, version mismatches. A `cix add` command handles the mechanics.\n\n**Updates**: Extension authors improve their work. Users who installed v1 need a path to v2. Without a package manager, \"update\" means \"delete and re-install manually.\"\n\n**Removal**: Clean removal requires knowing every file an extension installed. `cix rm` handles the bookkeeping.\n\nThe pattern is well-established. The novel element is **what's being packaged**: cognitive extensions that enhance human-AI collaboration, not libraries or frameworks.\n\n---\n\n## When Manual Management Breaks\n\nYou've installed 3 extensions by copying directories into `~/.claude/plugins/`. One gets updated -- which files do you replace? Another has a new dependency on a shared reference file -- do you know? A third changes its directory structure between versions. Manual management works for 1-2 extensions. At 5+, you're maintaining an undocumented dependency graph in your head.\n\ncix makes this a non-problem: `cix update` handles versioning, `cix add` resolves structure, `cix rm` cleans up completely.\n\n---\n\n## The Marketplace Model\n\ncix uses a source-based marketplace model:\n\n```\nSource (git repo)\n├── marketplace.json        # Registry of available packages\n├── plugin-a/               # Package directory\n│   ├── .claude-plugin/\n│   │   └── plugin.json     # Package manifest\n│   ├── skills/\n│   ├── agents/\n│   └── ...\n└── plugin-b/\n    └── ...\n```\n\n**Sources** are git repositories containing extension packages. Anyone can create a source by structuring a repo with a `marketplace.json` manifest.\n\n**Why git-based?** Git repos are:\n- Free to host (GitHub, GitLab, Codeberg)\n- Versionable (tags, branches)\n- Forkable (users can maintain their own variants)\n- Auditable (full history of changes)\n\nThis is the same model as Homebrew taps, Arch Linux AUR, and Nix channels.\n\n---\n\n## Design Decisions\n\n### Complementary by Default\n\nEvery extension in the cix ecosystem must follow the Collaborative Intelligence thesis: enhance human capability, don't replace it. This is enforced through:\n\n- **Quality evaluation**: The evaluator agent assesses extensions against CI design principles before marketplace inclusion\n- **Design documentation**: Extensions include methodology docs explaining *why* they're designed the way they are\n- **Transparency**: Extension behavior, sources, and reasoning are inspectable\n\n### Source-Agnostic\n\ncix doesn't run a central registry. It aggregates from user-registered sources. This means:\n\n- No single point of failure\n- Users control which sources they trust\n- Organizations can run private sources\n- The official mox-labs source is just one among potentially many\n\n### CLI-First\n\n```bash\ncix add arch-guild           # Install\ncix list                     # What's installed\ncix update                   # Update all\ncix rm arch-guild            # Remove\n```\n\nThe CLI is the primary interface. It follows the same conventions as `uv`, `cargo`, and `brew` -- subcommand-based, flags for options, human-readable output.\n\n---\n\n## Hexagonal Architecture\n\ncix follows hexagonal architecture (ports and adapters):\n\n**Domain**: Pure models -- Source, Package, Extension, Installation. No infrastructure dependencies.\n\n**Ports**: Protocol-based interfaces:\n- `RegistryPort` -- state persistence (sources, installations)\n- `RepositoryPort` -- package fetching from sources\n- `TargetPort` -- installation targets (Claude Code, potentially others)\n\n**Adapters**:\n- `_in/cli.py` -- Rich Click CLI (driving adapter)\n- `_out/filesystem_registry.py` -- JSON state in `~/.cix/`\n- `_out/git_repository.py` -- GitPython for source fetching\n- `_out/claude_code_target.py` -- Installation to `~/.claude/plugins/`\n\n**Why this matters:** The TargetPort abstraction means cix could support installation to Cursor, Windsurf, or any future AI coding tool -- one new adapter, zero domain changes.\n\nIn practice: when a new AI coding tool launches (Cursor, Windsurf, etc.), cix can support it with one new target adapter -- no domain changes, no reinstalling your extensions, no breaking existing workflows.\n\n---\n\n## Extension Types\n\ncix manages four types of Claude Code extensions:\n\n| Type | What It Does | Granularity |\n|------|-------------|-------------|\n| **Skill** | Decision frameworks and methodology for Claude | Loaded into context on activation |\n| **Agent** | Specialized subagent with orthogonality lock | Delegated to for specific perspectives |\n| **Hook** | Event-triggered behavior (PreToolUse, PostToolUse, etc.) | Runs automatically on events |\n| **MCP Server** | External service integration | Bridges systems via protocol |\n\nA **package** bundles one or more extensions into an installable unit. The `arch-guild` package, for example, contains 13 agents and 4 skills.\n\n---\n\n## Scope Boundaries\n\ncix has precise boundaries:\n\n| cix Does | cix Does Not |\n|----------|-------------|\n| Discover extensions from sources | Create extensions (use plugin-dev) |\n| Install to Claude Code plugins dir | Validate extension quality (use evaluator) |\n| Track what's installed where | Run extensions (Claude Code does that) |\n| Update and remove packages | Host a central registry |\n\nEach \"does not\" is handled by a different tool or agent in the ecosystem. cix is the package manager, not the IDE, linter, or runtime.\n",{"slug":23,"title":24,"content":25},"sources","Sources","# Sources\n\nResearch and evidence behind the cix package manager design.\n\n---\n\n## Research Synthesis\n\nThe evidence base for cix draws from two streams: the collaborative intelligence thesis (AI should amplify, not replace human capability) and package management history (CPAN through Nix). These converge on a design principle — cognitive extensions need the same lifecycle management as software dependencies, but with complementary design constraints that prevent skill atrophy.\n\n---\n\n## Collaborative Intelligence Thesis\n\n**Hemmer, P., Schemmer, M., Riefle, L., Vossing, M., & Kuehl, N. (2024). \"Complementarity in Human-AI Collaboration.\" European Journal of Information Systems.**\n\nEstablishes that complementary AI design -- where human and AI capabilities combine -- produces outcomes neither achieves alone. Substitutive design (AI replaces human effort) degrades human capability over time.\n\n**Relevance to cix:** The fundamental filter for the extension ecosystem. Every extension must be complementary by design.\n\n---\n\n**Blaurock, M., Buttgen, M., & Schepers, J. (2025). \"Designing Collaborative Intelligence Systems for Employee-AI Service Co-Production.\" Journal of Service Research, 28(4), 544-562.**\n\nTwo scenario-based experiments (n=654) establishing effect sizes:\n- Process Control: beta = 0.507 (strongest predictor)\n- Transparency: beta = 0.415\n- Engagement features: b = -0.555 (negative for frequent users)\n\n**Relevance to cix:** Extensions that maximize user control and transparency are prioritized. Engagement features (gamification, nudges) are actively discouraged.\n\n---\n\n**Lee, H.P., et al. (2025). \"The Impact of Generative AI on Critical Thinking.\" CHI 2025.**\n\nLarge-scale study (n=1,505): AI confidence negatively correlates with critical thinking enacted (beta = -0.69, p&lt;0.001). Higher self-confidence in own abilities correlates with maintained critical thinking.\n\n**Relevance to cix:** Extensions must build user confidence in their own judgment, not in the AI. This informs the mastery-over-performance design orientation.\n\n---\n\n## Package Management Precedent\n\n**Nix Package Manager. \"NixOS/nixpkgs: Nix Packages Collection.\" GitHub.**\n\nNix pioneered declarative, reproducible package management with channel-based sources (like cix's source model). The channel concept -- user-selected repositories of packages -- avoids central registry dependency.\n\n**Relevance to cix:** The source-based model draws from Nix channels and Homebrew taps: decentralized discovery, user-controlled trust.\n\n---\n\n**The Homebrew Project. \"Homebrew: The Missing Package Manager for macOS.\"**\n\nHomebrew's \"tap\" system lets users add third-party repositories of formulae. This decentralized model enables community growth without gatekeeping while maintaining a curated default tap.\n\n**Relevance to cix:** cix sources follow the same pattern -- a default marketplace plus user-addable sources.\n\n---\n\n## Hexagonal Architecture\n\n**Cockburn, A. (2005). \"Hexagonal Architecture (Ports and Adapters).\" alistair.cockburn.us.**\n\nPorts and adapters separate domain logic from infrastructure. The domain defines what it needs (ports); adapters provide how.\n\n**Relevance to cix:** The TargetPort abstraction means cix can install to Claude Code, Cursor, or any future target. RepositoryPort means sources could be git, HTTP, or local directories. Architecture enables evolution without rewrites.\n\n---\n\n## Extension Design Research\n\n**Bastani, H., et al. (2025). \"Generative AI without Guardrails Can Harm Learning.\" PNAS.**\n\nRCT (n=1,000): GPT Tutor (hints only) produced no learning harm. GPT Base (direct answers) caused 17% worse exam performance. Same technology, different design philosophy, opposite outcomes.\n\n**Relevance to cix:** The extension quality evaluation criteria. Extensions that give direct answers score lower than those providing reasoning frameworks. Design philosophy determines impact.\n\n---\n\n**Mozannar, H., et al. (2024). \"Reading Between the Lines: Modeling User Behavior and Costs in AI-Assisted Programming.\" CHI 2024.**\n\nDevelopers spend only 22.4% of coding time verifying AI suggestions. Verification behavior is the strongest predictor of code quality outcomes.\n\n**Relevance to cix:** Extensions should encourage verification, not bypass it. The ecosystem design principle: make verification natural, not effortful.\n\n---\n\n## Design Principles\n\n**Martin, R.C. (2017). \"Clean Architecture: A Craftsman's Guide to Software Structure and Design.\" Prentice Hall.**\n\nThe Dependency Rule: source code dependencies must point inward. Domain knows nothing of adapters. Adapters know about domain.\n\n**Relevance to cix:** Domain models (Source, Package, Extension) have zero infrastructure imports. CLI, git, and filesystem are adapters that depend on the domain, never the reverse.\n",[],[],2],"uses":{"params":["slug"]}}]}

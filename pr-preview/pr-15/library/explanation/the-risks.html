<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../../_app/immutable/assets/0.BJicj5Zp.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/CrossLinks.C4T6atsV.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/2.mFuDagjh.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/TableOfContents.DIs43wTQ.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.B9JAY-ug.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Cr7kXcYc.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DXXdKfFK.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DQIWNrPk.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/D0iwhpLH.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/D4v2vU6B.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CzKX1IyC.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.3Z1GRygV.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/PPVm8Dsz.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/i-IdDckD.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BPxar_6W.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Ey95jBeI.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DcJ2xzpH.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CpnKfs42.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DYueXv1s.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/EUq6mvGu.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.M7JUnjLu.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Dl8jxmRm.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C1v7wgkm.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Dvbz5Exl.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CV11oyJS.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Czc6TY_5.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/2.8wx36KRJ.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/8.DpMaukg5.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/mTfiAe1o.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Dv3oOIco.js"><!--12qhfyh--><meta name="description" content="Extensions that enhance human capability, not replace it."/><!----><!--1wa4r3o--><!----><title>Article — cix Library</title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><a href="#main" class="skip-link">Skip to content</a> <!--[--><nav class="site-nav svelte-qgym72" aria-label="Site navigation"><a href="../../" class="nav-wordmark svelte-qgym72">cix</a> <div class="nav-links svelte-qgym72"><!--[--><a href="../../ethos" class="nav-link svelte-qgym72">ethos</a><a href="../../catalog" class="nav-link svelte-qgym72">catalog</a><a href="../../library" class="nav-link svelte-qgym72">library</a><!--]--></div></nav><!--]--> <div class="page svelte-12qhfyh has-nav"><!--[--><!----><main id="main" class="library-layout svelte-12dzc7l"><!----><div class="article-wrapper svelte-1wa4r3o"><nav class="article-breadcrumb svelte-1wa4r3o"><a href="../../library" class="svelte-1wa4r3o">library</a> <span class="breadcrumb-sep svelte-1wa4r3o">/</span> <a href="../../library#explanation" class="svelte-1wa4r3o">explanation</a></nav> <article class="prose svelte-1wa4r3o"><!----><h1>The Risks of Uncritical AI Adoption</h1> <p>Seven categories of measurable harm from substitutive AI use in software development.</p> <hr/> <h2>Sources</h2> <ul><li><a href="https://www.thelancet.com/journals/langas/article/PIIS2468-1253(24)00301-2/fulltext" rel="nofollow">Budzyń et al. (2025). Effect of AI-Assisted Colonoscopy. Lancet Gastroenterology &amp; Hepatology.</a></li> <li><a href="https://www.mdpi.com/2075-4698/15/1/6" rel="nofollow">Gerlich (2025). AI Tools in Society. MDPI Societies.</a></li> <li><a href="https://www.media.mit.edu/" rel="nofollow">Kosmyna et al. (2025). Your Brain on ChatGPT. MIT Media Lab.</a></li> <li><a href="https://dl.acm.org/doi/full/10.1145/3706598.3713778" rel="nofollow">Lee et al. (2025). Impact of Generative AI on Critical Thinking. CHI.</a></li> <li><a href="https://arxiv.org/abs/2507.09089" rel="nofollow">METR (2025). Measuring AI Impact on Developer Productivity. RCT.</a></li> <li><a href="https://www.veracode.com/" rel="nofollow">Veracode (2025). AI Code Generation Security Analysis.</a></li> <li><a href="https://arxiv.org/" rel="nofollow">Shukla et al. (2025). Security Degradation in AI-Generated Code. arXiv.</a></li> <li><a href="https://arxiv.org/" rel="nofollow">Perry et al. (2025). Vulnerability Inheritance in AI Code. arXiv.</a></li> <li><a href="https://www.gitclear.com/" rel="nofollow">GitClear (2025). Coding on Copilot: 2024 Data.</a></li> <li><a href="https://dora.dev/" rel="nofollow">DORA (2024). State of DevOps Report.</a></li> <li><a href="https://www.pnas.org/doi/10.1073/pnas.2422633122" rel="nofollow">Bastani et al. (2025). Generative AI Can Harm Learning. PNAS.</a></li> <li><a href="https://dl.acm.org/doi/" rel="nofollow">Bansal et al. (2021). Does the Whole Exceed its Parts? CHI.</a></li> <li><a href="https://survey.stackoverflow.co/2024/" rel="nofollow">Stack Overflow Developer Survey (2024-2025).</a></li> <li><a href="https://arxiv.org/abs/2510.22954" rel="nofollow">Jiang et al. (2025). Artificial Hivemind. NeurIPS Best Paper.</a></li> <li><a href="https://arxiv.org/abs/2505.17241" rel="nofollow">Meta-analysis (2025). Generative AI and Creativity. arXiv.</a></li> <li><a href="https://www.pnas.org/" rel="nofollow">Hong &amp; Page (2004). Groups of Diverse Problem Solvers. PNAS.</a></li> <li><a href="https://en.wikipedia.org/wiki/Variety_(cybernetics)" rel="nofollow">Ashby (1956). Law of Requisite Variety.</a></li></ul> <hr/> <h2>Abstract</h2> <p>AI adoption creates seven measurable risk categories. Cognitive skills atrophy at 20% after three months of AI-assisted practice (Budzyń). <span class="ev ev-moderate" title="Lancet crossover RCT, medical domain">◐</span> Code quality degrades with 8x duplication increases and refactoring plummets (GitClear, 211M LOC). <span class="ev ev-moderate" title="Large-scale code analysis, observational">◐</span> Security deteriorates as 45% of AI-generated code contains critical vulnerabilities (Veracode). <span class="ev ev-moderate" title="Large-scale security analysis">◐</span></p> <p>The perception gap compounds every risk. Developers believe they’re 24% faster with AI while measurements show they’re 19% slower — a 43-point miscalibration (METR). <span class="ev ev-moderate" title="RCT, n=16, rigorous but small">◐</span> Trust in AI accuracy dropped from 43% to 33% in one year, yet adoption rose from 76% to 84% (Stack Overflow). <span class="ev ev-moderate" title="Large survey, observational">◐</span> People use tools they don’t trust, perceive benefits they don’t get, and can’t see the degradation.</p> <p>The risks aren’t hypothetical. They’re measured, cataloged, and accelerating.</p> <hr/> <h2>Explanation</h2> <h3>1. Skill Atrophy</h3> <p><strong>The evidence is stark.</strong> Remove AI assistance after three months, and diagnostic accuracy drops 20% (Budzyń). <span class="ev ev-moderate" title="Lancet crossover RCT, colonoscopy study">◐</span> This isn’t forgetting — it’s neural pathway degradation from disuse. The brain treats AI-assisted work differently at a physiological level, with “systematically scaled down” connectivity during collaboration (Kosmyna, MIT Media Lab). <span class="ev ev-moderate" title="EEG study, small n">◐</span></p> <p>The mechanism is cognitive offloading: r = -0.75 correlation between delegating thinking to AI and critical thinking capacity (Gerlich, n=666). <span class="ev ev-moderate" title="Survey study, single source">◐</span> When AI handles reasoning, humans stop performing it. This isn’t laziness — it’s rational resource allocation. Why think when AI does it faster?</p> <p><strong>The bifurcation matters.</strong> Not all skills atrophy equally:</p> <table><thead><tr><th>Skill Type</th><th>Vulnerability</th><th>Why</th></tr></thead><tbody><tr><td><strong>Cognitive</strong> (design, architecture)</td><td>High</td><td>Easily offloaded</td></tr><tr><td><strong>Perceptual</strong> (pattern recognition)</td><td>High</td><td>Requires active practice</td></tr><tr><td><strong>Motor/Procedural</strong> (typing, tools)</td><td>Low</td><td>Physically encoded</td></tr></tbody></table> <p>The skills most at risk are exactly those most valuable: reasoning about systems, analyzing edge cases, designing abstractions, recognizing code smells. Meanwhile, typing speed and IDE shortcuts — the procedural skills — remain intact. We’re losing capability where it matters most.</p> <p><strong>Aviation provides the sobering parallel.</strong> Seventy-seven percent of pilots report degraded manual flying skills from automation reliance. <span class="ev ev-moderate" title="Aviation domain, survey data">◐</span> Software development involves more abstract reasoning than motor control. Whether cognitive skills atrophy faster or slower than motor skills remains unknown, but the mechanism is identical: remove practice, lose proficiency. <span class="ev ev-speculative" title="Cross-domain inference">◌</span></p> <h3>2. Security Degradation</h3> <p><strong>Forty-five percent.</strong> That’s the proportion of AI-generated code containing critical vulnerabilities (Veracode). <span class="ev ev-moderate" title="Large-scale security audit">◐</span> Not minor issues — critical. SQL injection, hardcoded credentials, insecure deserialization, missing validation. The patterns AI learned from training data, now replicated at scale.</p> <p><strong>The iteration paradox compounds the problem.</strong> Common intuition suggests more refinement produces more secure code. Measurements show the opposite. Vulnerabilities per thousand lines of code: 2.1 on first generation, 6.2 after refinement (Shukla). <span class="ev ev-moderate" title="arXiv preprint, security analysis">◐</span> Each iteration adds code without removing vulnerabilities from previous passes. Security degrades with effort.</p> <p>Perry et al. analyzed 7,703 files. <span class="ev ev-moderate" title="Large-scale file analysis">◐</span> The finding: AI inherits vulnerabilities from training data systematically. When Stack Overflow is training corpus and Stack Overflow contains insecure patterns, AI reproduces them faithfully. The model has no concept of “this pattern is insecure.” It knows only “this pattern is common.”</p> <p><strong>Model size provides no protection.</strong> Larger models aren’t more secure. Better prompts don’t eliminate the vulnerability inheritance. The only reliable countermeasure is independent security review — which requires the security expertise that AI is actively eroding through offloading.</p> <h3>3. Code Quality Erosion</h3> <p><strong>Eight times.</strong> Code duplication increased 8x after AI adoption (GitClear, 211M lines analyzed). <span class="ev ev-moderate" title="Large-scale observational study">◐</span> Refactoring activity plummeted. Copy-paste patterns surged. The codebase shifts from architected to assembled.</p> <p>The mechanism: AI generates fresh solutions without awareness of existing patterns. Each generation produces plausible code that works in isolation but duplicates what already exists. The human who would have searched for reusable components instead gets a new implementation — faster to accept than to find and refactor.</p> <p><strong>DORA metrics tell the downstream story.</strong> Deployment stability: -7.2%. Throughput: -1.5%. (DORA 2024) <span class="ev ev-moderate" title="Industry survey, large sample">◐</span> The most rigorous measurement of engineering effectiveness shows AI correlating with slight degradation across both stability and speed. The quality debt compounds silently.</p> <p>The explainability gap opens wider each sprint. Developer writes 500 LOC, understands all. AI generates 2,000 LOC, developer understands 60%. Next iteration builds on that 60%, understanding drops to 30%. By sprint N, the codebase is assembled from components the developer never designed and doesn’t fully comprehend. Debugging becomes archaeological work. Maintenance becomes guesswork. Architecture evolution becomes impossible.</p> <h3>4. The Perception Gap</h3> <p><strong>You can’t fix what you can’t see.</strong> Experienced developers predicted AI would make them 24% faster. Rigorous measurement showed they were 19% slower. The gap: 43 percentage points between perception and reality (METR). <span class="ev ev-moderate" title="RCT, n=16, controlled conditions">◐</span></p> <p>Time spent prompting, reviewing, fixing, integrating — all uncounted in subjective assessment. The effort feels lighter because generation (visible work) disappears. Verification (invisible work) appears. The task completes. The illusion persists.</p> <p><strong>The trust-behavior divergence amplifies the problem.</strong> Trust in AI coding accuracy: 43% in 2023, dropped to 33% in 2024. Usage: 76% to 84% in the same period (Stack Overflow). <span class="ev ev-moderate" title="Developer survey, large sample">◐</span> Trust drops, adoption rises. People use tools they don’t trust, perceive benefits contradicted by measurement, and make decisions based on false premises.</p> <p>Managers allocate timelines assuming productivity gains that don’t exist. Developers underinvest in verification because the work feels complete. Teams ship faster while quality degrades. The perception gap prevents correction at every level.</p> <h3>5. Automation Complacency</h3> <p><strong>Confidence in AI negatively predicts critical thinking at β = -0.69 (Lee et al., CHI 2025).</strong> <span class="ev ev-strong" title="CHI peer-reviewed, n=319, structural equation modeling">●</span> The more you trust AI, the less you verify it. The less you verify, the more errors propagate.</p> <p>The mechanism is automation bias: repeated experience of AI being correct → reduced vigilance. This manifests in verification latency — time between receiving AI output and meaningful review. Immediate acceptance signals rubber-stamping. Ten to thirty seconds suggests scanning, not reviewing. Genuine review takes minutes.</p> <p><strong>Explanations make it worse.</strong> When AI provides reasoning alongside answers, acceptance increases regardless of correctness (Bansal, CHI 2021). <span class="ev ev-strong" title="CHI peer-reviewed, controlled experiment">●</span> Correct AI + explanation: slight help. Incorrect AI + explanation: performance degrades. The explanation creates false confidence. Human evaluation collapses.</p> <p>Developers spend only 22.4% of coding time verifying AI suggestions. <span class="ev ev-moderate" title="Observational study">◐</span> The correction rate — how often suggestions get modified before acceptance — provides calibration signal. Under 5%: automation bias risk. 10-30%: healthy. Above 50%: AI ineffective for this domain. Most developers can’t report their own correction rate.</p> <h3>6. Homogenization</h3> <p><strong>g = -0.863.</strong> Meta-analysis across 28 studies, n=8,214. <span class="ev ev-strong" title="Meta-analysis, large sample">●</span> AI-assisted outputs show 0.863 standard deviations less diversity than human-only outputs. This isn’t small. It’s structural convergence toward training data patterns.</p> <p>Jiang et al. (NeurIPS 2025 Best Paper) tested 70+ LLMs across 26,000 queries. <span class="ev ev-strong" title="Best Paper, comprehensive evaluation">●</span> Convergence appeared across all models. Temperature scaling didn’t help. Ensembling didn’t help. The models share training data, converge to shared patterns, produce homogenized outputs regardless of sampling method.</p> <p><strong>Why homogenization matters:</strong> Hong &amp; Page proved mathematically that diverse groups outperform best-ability homogeneous groups for complex problem-solving. <span class="ev ev-strong" title="PNAS, formal proof">●</span> Diversity isn’t fairness theater — it’s functional necessity. Different perspectives catch different errors, explore different solutions, prevent groupthink failure modes.</p> <p>Ashby’s Law of Requisite Variety: a system can only regulate variety in its environment if it has equal or greater internal variety. <span class="ev ev-moderate" title="Cybernetics principle, theoretical">◐</span> When everyone uses the same AI generating the same solutions, the system loses the variety needed to handle unexpected problems. Fragility increases invisibly until the shock that reveals it.</p> <h3>7. Novice Vulnerability</h3> <p><strong>Seventeen percent.</strong> Students with unrestricted ChatGPT access scored 17% worse on exams without AI (Bastani, PNAS, n=1,000). <span class="ev ev-strong" title="RCT, large sample, PNAS">●</span> Students with hint-only AI showed no degradation. Same technology. Different interaction pattern. Opposite outcomes.</p> <p>The mechanism: direct answers bypass desirable difficulties — the productive struggle that builds understanding. Errors force diagnosis. Diagnosis builds mental models. Remove errors, remove learning. The control group encountered median 3 errors. AI users who delegated encountered 1 error. They finished faster and learned nothing about why their code didn’t work. The errors were the curriculum.</p> <p><strong>Novices lack the foundational schema needed to evaluate AI output.</strong> An expert sees generated code and recognizes patterns, evaluates tradeoffs, spots subtle issues. A novice sees generated code that runs and assumes correctness. Expert judgment catches AI failures. Novice acceptance amplifies them.</p> <p>A novice who learns to program with AI may never develop:</p> <ul><li>Mental models of program execution</li> <li>Debugging intuition</li> <li>Design reasoning</li> <li>Error recognition patterns</li></ul> <p>These aren’t taught — they’re built through struggle. Receiving solutions feels like learning but produces no schema formation. The brain never engages. The knowledge never encodes.</p> <h3>The Compounding Problem</h3> <p><strong>These seven risks don’t exist in isolation.</strong> They compound.</p> <p>Skill atrophy → reduced ability to catch security issues → vulnerabilities propagate.
Perception gap → under-investment in verification → automation complacency → more errors.
Code quality erosion → harder to debug → more reliance on AI → faster skill atrophy.
Homogenization → less diverse solutions → fragility → shocks the system can’t absorb.
Novice vulnerability → no foundational schema → permanent capability gap → dependency.</p> <p>Each risk makes the others worse. The system is dynamically unstable.</p> <h3>When Risk Is Acceptable</h3> <p><strong>Not all AI use produces these outcomes.</strong> The determining factor is complementary vs substitutive design.</p> <table><thead><tr><th>Pattern</th><th>Human Role</th><th>Outcome</th></tr></thead><tbody><tr><td><strong>Substitutive</strong></td><td>Approves AI work</td><td>Atrophy</td></tr><tr><td><strong>Complementary</strong></td><td>Steers AI, retains reasoning</td><td>Capability maintained</td></tr></tbody></table> <p>Complementary patterns that preserve capability:</p> <ul><li>AI handles boilerplate, human handles architecture (Approach Crafting)</li> <li>AI generates, human comprehends through questions (86% mastery pattern)</li> <li>AI provides perspective, human synthesizes across multiple viewpoints</li> <li>AI explains reasoning, human evaluates logic chains</li></ul> <p>The distinction: who does the thinking? If AI thinks and human approves, capability erodes. If human thinks and AI amplifies, capability compounds.</p> <h3>The Unsolved Questions</h3> <p><strong>No longitudinal study tracks developer capability over 2-5 years of heavy AI use.</strong> We have three-month medical studies showing 20% skill loss. We have cross-sectional developer data showing perception gaps and reduced thinking. But the multi-year trajectory with varied interaction patterns remains unknown.</p> <p>Whether cognitive skills atrophy faster or slower than motor skills is speculative. <span class="ev ev-speculative" title="Inference from adjacent domains">◌</span> Whether early-career AI exposure prevents schema formation permanently is unknown. <span class="ev ev-speculative" title="Hypothesis, no direct evidence">◌</span> Whether complementary design actually prevents long-term atrophy is plausible but unproven beyond 12 weeks. <span class="ev ev-speculative" title="Inference from mechanism understanding">◌</span></p> <p>The research we need: cohort study, multiple interaction patterns, capability assessment at 6/12/24 months, measuring both assisted and unassisted performance. Until that exists, we’re making trillion-dollar bets on inferences from short-term studies.</p> <h3>Risk Mitigation</h3> <p>The risks are real, measured, and structural. They’re not eliminated by better models or clearer prompts. They require design interventions:</p> <p><strong>Preserve the generative step</strong> in learning contexts. Attempt-first protocol: 15-30 minutes unassisted before AI consultation.</p> <p><strong>Inject metacognitive friction</strong> at decision points. Planning, monitoring, evaluation checkpoints. Single-point friction (“are you sure?”) is insufficient.</p> <p><strong>Reduce AI-confidence signals.</strong> Don’t project certainty. Show uncertainty. Invite verification.</p> <p><strong>Boost self-confidence signals.</strong> “You have the production context I lack.” Shift authority back to human.</p> <p><strong>Maintain variety.</strong> Don’t standardize on single AI. Multiple perspectives, human synthesis, preserved diversity.</p> <p><strong>Measure what matters.</strong> Correction rate, verification latency, independent capability checks. Perception is unreliable.</p> <p><strong>Protect novices.</strong> Hint-only mode for learning. Direct answers prevent schema formation.</p> <h3>Summary</h3> <p>Seven risk categories, all measured:</p> <ol><li><strong>Skill atrophy</strong>: 20% at 3 months, cognitive skills most vulnerable</li> <li><strong>Security degradation</strong>: 45% critical vulnerabilities, worse with iteration</li> <li><strong>Code quality erosion</strong>: 8x duplication, -7.2% stability</li> <li><strong>Perception gap</strong>: 43-point miscalibration prevents correction</li> <li><strong>Automation complacency</strong>: β = -0.69 confidence → less critical thinking</li> <li><strong>Homogenization</strong>: g = -0.863 diversity reduction, fragility increase</li> <li><strong>Novice vulnerability</strong>: 17% learning harm from direct answers</li></ol> <p>The risks compound. The perception gap prevents correction. Substitutive use guarantees degradation. Complementary design offers protection but requires intentional effort.</p> <p>The question isn’t whether to use AI. The question is whether we design collaboration that maintains human capability or surrenders it.</p><!----></article> <!--[--><nav class="article-nav svelte-1l1vath" aria-label="Article navigation"><span class="article-position svelte-1l1vath">02 of 13</span> <div class="article-nav-links svelte-1l1vath"><!--[--><a href="../../library/explanation/what-is-ci" class="nav-prev svelte-1l1vath"><span class="nav-arrow svelte-1l1vath">←</span> <span class="nav-label">What is CI</span></a><!--]--> <!--[--><a href="../../library/explanation/the-path-forward" class="nav-next svelte-1l1vath"><span class="nav-label">The Path Forward</span> <span class="nav-arrow svelte-1l1vath">→</span></a><!--]--></div></nav><!--]--></div><!----><!----></main><!----><!--]--><!----></div> <div class="experimental-tag svelte-12qhfyh" aria-hidden="true">experimental</div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_39lsyk = {
						base: new URL("../..", location).pathname.slice(0, -1),
						assets: "/cix/pr-preview/pr-15"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../../_app/immutable/entry/start.B9JAY-ug.js"),
						import("../../_app/immutable/entry/app.3Z1GRygV.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 2, 8],
							data: [null,null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>

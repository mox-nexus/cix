{"type":"data","nodes":[null,{"type":"data","data":[{"extension":1},{"slug":2,"kind":3,"manifest":4,"tagline":16,"readme":17,"components":18,"variant":22,"tags":10},"arch-guild","plugin",{"name":2,"version":5,"description":6,"author":7,"license":9,"keywords":10},"0.1.0","Architectural reasoning with The Guild. Use when: reviewing architecture, evaluating design, checking production readiness, scaffolding services, making boundary decisions.",{"name":8},"Yash Vyas","MIT",[11,12,13,14,15],"architecture","design","operations","council","hexagonal","Architectural reasoning through 13 specialized agents with orthogonal perspectives — each locked to their domain, forcing genuine perspective diversity.","# arch-guild\n\nArchitectural reasoning through 13 specialized agents with orthogonal perspectives — each locked to their domain, forcing genuine perspective diversity.\n\n## What Problem This Solves\n\nArchitecture decisions need multiple perspectives. A caching decision involves economics (cost), consistency (distributed systems), security (DoS vectors), and capacity (memory bounds). Most reviews miss something because they come from one viewpoint.\n\nThe Guild provides structured multi-perspective evaluation. Each agent has a defined domain and **orthogonality lock** — they can only discuss their area. This prevents homogenization and forces genuine perspective diversity.\n\n## When to Use\n\nThe Guild activates when you:\n\n- Review architecture for a service or system\n- Evaluate design decisions (caching, API protocol, boundaries)\n- Check production readiness\n- Make tradeoff decisions between competing concerns\n- Need to understand why legacy code exists before changing it\n\n**Example prompts:**\n- \"Review this architecture for a payment system\"\n- \"Should I use Redis or in-memory HashMap for caching?\"\n- \"Is this service ready for production?\"\n- \"Convene the full guild on this proposal\"\n\n## The 13 Agents\n\nAgents are named after thought leaders whose work defines their domain (Lamport for distributed systems, Dijkstra for correctness, Taleb for resilience). See `docs/explanation/bibliography.md` for the full lineage.\n\n### 7 Masters (Always Active)\n\nThese agents review every architectural decision.\n\n| Agent | Domain | Core Question |\n|-------|--------|---------------|\n| **K** | Strategic | What forces are at play? What move creates options? |\n| **Karman** | Ontological/Naming | Does code model match business reality? |\n| **Burner** | Structural/Boundaries | Are dependencies clean? Do they point inward? |\n| **Lamport** | Temporal/Distributed | What happens with latency, partitions, eventual consistency? |\n| **Erlang** | Hydraulic/Capacity | If inflow exceeds outflow, where is the valve? |\n| **Vector** | Adversarial/Security | If I control the input, how do I break this? |\n| **Ace** | Psychocentric/DX | Can the next developer figure this out in 15 minutes? |\n\n### 6 Specialists (Context-Triggered)\n\nThese agents activate when specific conditions appear.\n\n| Agent | Domain | Trigger |\n|-------|--------|---------|\n| **Ixian** | Empirical/Validation | Always — mandatory post-consensus |\n| **Dijkstra** | Deductive/Correctness | Critical paths: auth, payments, state machines |\n| **Knuth** | Complexity/Performance | Loops, aggregations, high-cardinality data |\n| **Lotfi** | Fuzzy/Tradeoffs | Agent deadlocks (K says yes, Dijkstra says no) |\n| **Taleb** | Antifragile/Resilience | Production readiness, failure modes |\n| **Chesterton** | Diachronic/Legacy | Removing old code, refactoring legacy systems |\n\n## Guild Modes\n\n| Mode | Agents | Use When |\n|------|--------|----------|\n| **Methodology** | Relevant subset | Default — let context determine |\n| **Quick** | 7 Masters | Fast review, broad coverage |\n| **Focus** | 3-4 targeted | Specific concern (security, performance) |\n| **Full** | All 13 | Major decisions, comprehensive review |\n\n## Verdicts\n\n| Verdict | Meaning | Action |\n|---------|---------|--------|\n| **APPROVE** | No concerns from this perspective | Proceed |\n| **CONCERN** | Minor issues, acceptable short-term | Proceed with awareness |\n| **OBJECTION** | Significant issues | Address before proceeding |\n| **BLOCK** | Fundamental problem | Cannot proceed |\n\n## The Ratchet\n\nThe Guild learns across sessions. After significant decisions, capture learnings to `.claude/guild-ratchet.md` in your project:\n\n```markdown\n## 2026-01-15: Redis vs HashMap Decision\n\n### Blocking Agents\n- Lamport: Per-instance HashMap breaks cache consistency with 4 replicas\n\n### Principle Extracted\n> \"In-memory caching requires single-writer architecture or accepting stale reads.\"\n\n### Future Trigger\nMulti-instance deployments with shared state\n```\n\nThe SessionStart hook loads this automatically. Disable with `SKIP_GUILD_RATCHET=1`.\n\n## Structure\n\n```\narch-guild/\n├── skills/\n│   ├── architecture/    # Guild methodology, hexagonal, event-driven\n│   ├── design/          # SOLID, API protocols, component design\n│   └── operations/      # Production readiness, chaos engineering\n├── agents/              # 13 agent definitions\n├── references/          # Shared methodology\n├── hooks/               # SessionStart ratchet loader\n└── evals/               # Activation tests\n```\n\n## Sources\n\nThe agents draw from foundational work in computer science:\n\n| Agent | Source |\n|-------|--------|\n| Dijkstra | \"The Humble Programmer\" (1972) — correctness through proof |\n| Lamport | \"Time, Clocks, and the Ordering of Events\" (1978) — distributed systems |\n| Taleb | *Antifragile* (2012) — resilience under stress |\n| Knuth | \"Structured Programming with go to Statements\" (1974) — complexity analysis |\n\nFull bibliography with 24 verified sources: `docs/explanation/bibliography.md`\n\n## License\n\nMIT\n",{"agents":19,"skills":20,"hooks":21,"commands":21},13,3,0,"spark"],"uses":{"params":["slug"]}}]}

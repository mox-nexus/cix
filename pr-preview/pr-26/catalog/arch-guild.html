<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../_app/immutable/assets/0.04mfEt8Y.css" rel="stylesheet">
		<link href="../_app/immutable/assets/CrossLinks.C4T6atsV.css" rel="stylesheet">
		<link href="../_app/immutable/assets/5.Bnuf7QZ4.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.P5EgdSjT.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DOTpK9Mq.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/iyO_HpW3.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/_cEvoN5f.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/D0iwhpLH.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/nnUXDhQR.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/Cs0QLTHR.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.DOouVLp1.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BPYyHSBz.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/2hgU3PCP.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/C4-dLuTv.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/_Dz5Oby6.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DtLL33Bf.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/a8oTfHeT.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CFsY3MpS.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.u0FGVUe6.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BwsKPAvP.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BbhyhsYm.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/Dx7ODcuM.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/5.vMkw6T3Y.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BFxfVKZg.js"><!--12qhfyh--><meta name="description" content="Extensions that enhance human capability, not replace it."/><!----><!--wzm642--><meta name="description" content="Architectural reasoning with The Guild. Use when: reviewing architecture, evaluating design, checking production readiness, scaffolding services, making boundary decisions."/><!----><title>arch-guild — cix</title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><a href="#main" class="skip-link">Skip to content</a> <!--[--><nav class="site-nav svelte-qgym72" aria-label="Site navigation"><a href="../" class="nav-wordmark svelte-qgym72">cix</a> <div class="nav-links svelte-qgym72"><!--[--><a href="../ethos" class="nav-link svelte-qgym72">ethos</a><a href="../catalog" class="nav-link svelte-qgym72">catalog</a><a href="../library" class="nav-link svelte-qgym72">library</a><!--]--></div></nav><!--]--> <div class="page svelte-12qhfyh has-nav"><!--[!--><!----><main id="main" class="detail-page svelte-wzm642" style="--variant-color: var(--spark-core)"><nav class="detail-back svelte-wzm642"><a href="../catalog" class="svelte-wzm642">← catalog</a></nav> <header class="detail-header svelte-wzm642"><div class="header-top svelte-wzm642"><h1 class="svelte-wzm642">arch-guild</h1> <span class="detail-kind svelte-wzm642">plugin</span> <span class="detail-version svelte-wzm642">0.1.0</span></div> <p class="detail-description svelte-wzm642">Architectural reasoning with The Guild. Use when: reviewing architecture, evaluating design, checking production readiness, scaffolding services, making boundary decisions.</p> <!--[--><div class="detail-inventory svelte-wzm642"><!--[--><span class="inv-item svelte-wzm642">13 agents</span><span class="inv-item svelte-wzm642">4 skills</span><!--]--></div><!--]--> <!--[--><div class="detail-tags svelte-wzm642"><!--[--><span class="tag svelte-wzm642">architecture</span><span class="tag svelte-wzm642">design</span><span class="tag svelte-wzm642">operations</span><span class="tag svelte-wzm642">council</span><span class="tag svelte-wzm642">hexagonal</span><!--]--></div><!--]--></header> <!--[--><nav class="detail-tabs svelte-wzm642" role="tablist"><!--[--><button role="tab" class="tab svelte-wzm642 active" aria-selected="true">README <!--[!--><!--]--></button><button role="tab" class="tab svelte-wzm642" aria-selected="false">Explanation <!--[--><span class="tab-count svelte-wzm642">3</span><!--]--></button><!--]--></nav><!--]--> <article class="detail-content svelte-wzm642 prose"><!--[--><!----><h1>arch-guild</h1>
<p>13 agents, orthogonal perspectives, structured architectural deliberation.</p>
<p><strong>Skills</strong>: architecture, design, operations, scaffold
<strong>Agents</strong>: K, Karman, Burner, Lamport, Erlang, Vector, Ace, Ixian, Dijkstra, Knuth, Lotfi, Taleb, Chesterton</p>
<p>Each agent has one domain and an orthogonality lock — they cannot discuss anything outside it. This forces genuine perspective diversity instead of 13 variations of the same opinion.</p>
<h2>Quick start</h2>
<pre><code>&quot;Review this architecture&quot;           → Guild deliberation
&quot;Is this ready for production?&quot;      → Operations lenses (Taleb/Erlang/Vector)
&quot;Scaffold a hex service&quot;             → Workflow-driven project scaffolding
&quot;Should I use Redis or HashMap?&quot;     → Focus mode on relevant agents
</code></pre>
<h2>License</h2>
<p>MIT</p>
<!----><!--]--></article></main><!----><!--]--><!----></div> <div class="experimental-tag svelte-12qhfyh" aria-hidden="true">experimental</div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_t0r7ei = {
						base: new URL("..", location).pathname.slice(0, -1),
						assets: "/cix/pr-preview/pr-26"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../_app/immutable/entry/start.P5EgdSjT.js"),
						import("../_app/immutable/entry/app.DOouVLp1.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 5],
							data: [null,(function(a){a[0]="architecture";a[1]="design";a[2]="operations";a[3]="council";a[4]="hexagonal";return {type:"data",data:{extension:{slug:"arch-guild",kind:"plugin",manifest:{name:"arch-guild",version:"0.1.0",description:"Architectural reasoning with The Guild. Use when: reviewing architecture, evaluating design, checking production readiness, scaffolding services, making boundary decisions.",author:{name:"Mox Labs",email:"mox.rnd@gmail.com"},license:"MIT",keywords:a},tagline:"13 agents, orthogonal perspectives, structured architectural deliberation.",readme:"# arch-guild\n\n13 agents, orthogonal perspectives, structured architectural deliberation.\n\n**Skills**: architecture, design, operations, scaffold\n**Agents**: K, Karman, Burner, Lamport, Erlang, Vector, Ace, Ixian, Dijkstra, Knuth, Lotfi, Taleb, Chesterton\n\nEach agent has one domain and an orthogonality lock — they cannot discuss anything outside it. This forces genuine perspective diversity instead of 13 variations of the same opinion.\n\n## Quick start\n\n```\n\"Review this architecture\"           → Guild deliberation\n\"Is this ready for production?\"      → Operations lenses (Taleb/Erlang/Vector)\n\"Scaffold a hex service\"             → Workflow-driven project scaffolding\n\"Should I use Redis or HashMap?\"     → Focus mode on relevant agents\n```\n\n## License\n\nMIT\n",components:{agents:13,skills:4,hooks:0,commands:0},variant:"spark",tags:a,docs:{explanation:[{slug:"bibliography",title:"Guild Sources",content:"# Guild Sources\n\nAuthoritative references for Domain-Driven Design, architecture patterns, and the thought leaders whose names inspire Guild agents.\n\n---\n\n## The Guild\n\nSourced from foundational thinkers and inspirational thought leaders.\n\n### Edsger Dijkstra (1930–2002)\n\n> \"The competent programmer is fully aware of the strictly limited size of his own skull; therefore he approaches the programming task in full humility.\"\n\n> \"The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.\"\n\n> \"Simplicity is prerequisite for reliability.\"\n\nTuring Award 1972. Structured programming, semaphores, algorithm correctness. His lecture \"The Humble Programmer\" is a call for intellectual humility in the face of complexity.\n\n### Leslie Lamport (1941–)\n\n> \"A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable.\"\n\n> \"Thinking doesn't guarantee that we won't make mistakes. But not thinking guarantees that we will.\"\n\nTuring Award 2013. Formalized time and ordering in distributed systems. Paxos, TLA+, LaTeX. His 1978 paper \"Time, Clocks, and the Ordering of Events\" is among the most cited in computer science.\n\n### Donald Knuth (1938–)\n\n> \"Science is what we understand well enough to explain to a computer. Art is everything else we do.\"\n\n> \"The best programs are written so that computing machines can perform them quickly and so that human beings can understand them clearly.\"\n\n> \"Premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.\"\n\nTuring Award 1974. *The Art of Computer Programming*, TeX, literate programming. His rigorous analysis of algorithms established computer science as a mathematical discipline.\n\n### Nassim Nicholas Taleb (1960–)\n\n> \"Antifragility is beyond resilience or robustness. The resilient resists shocks and stays the same; the antifragile gets better.\"\n\n> \"If you do not take risks for your opinion, you are nothing.\"\n\n> \"Things designed by people without skin in the game tend to grow in complication (before their final collapse).\"\n\nBlack Swans, antifragility, skin in the game. His insight that some systems should *benefit* from stress fundamentally reframes reliability engineering.\n\n### Lotfi Zadeh (1921–2017)\n\n> \"As complexity rises, precise statements lose meaning and meaningful statements lose precision.\"\n\n> \"Fuzzy logic is not fuzzy. It is a precise logic of imprecision and approximate reasoning.\"\n\nInvented fuzzy logic — real-world categories don't have sharp boundaries. Enables reasoning about partial truth and trade-offs that can't be resolved with binary yes/no.\n\n### G.K. Chesterton (1874–1936)\n\n> \"If you don't see the use of it, I certainly won't let you clear it away. Go away and think. Then, when you can come back and tell me that you do see the use of it, I may allow you to destroy it.\"\n\nNot a technologist, but \"Chesterton's Fence\" is foundational to software maintenance. Before removing \"dead\" code, understand why it exists. That mysterious `sleep(100)` might be a race condition fix.\n\n### Joe Armstrong (1950–2019)\n\n> \"Only program the happy case. When the real world deviates from the specification, let it crash.\"\n\n> \"To make fault-tolerant systems you need TWO computers. You can never make a fault-tolerant system using just one.\"\n\nCreated Erlang. \"Let it crash\" — fault tolerance requires isolation. Erlang powers 90% of internet traffic through telecom switches.\n\n### Aaron Swartz (1986–2013)\n\n> \"Information is power. But like all power, there are those who want to keep it for themselves.\"\n\n> \"Think deeply about things. Don't just go along because that's the way things are or that's what your friends say.\"\n\nCo-authored RSS at 14, helped build Creative Commons, co-founded Reddit. His question — *who owns knowledge?* — remains urgent.\n\n---\n\n## Domain-Driven Design\n\n### Evans, Eric (2003)\n\n**Domain-Driven Design: Tackling Complexity in the Heart of Software**\n\n- **Author:** Eric Evans\n- **Publisher:** Addison-Wesley Professional\n- **Publication Date:** August 20, 2003\n- **ISBN-10:** 0321125215\n- **ISBN-13:** 978-0321125217\n- **Pages:** 560\n- **URL:** https://www.dddcommunity.org/book/evans_2003/\n\nThe foundational text for Domain-Driven Design. Evans presents a systematic approach for tackling complexity in software through domain modeling.\n\n#### Key Concepts\n\n**Ubiquitous Language**\n\n> \"To communicate effectively, the code must be based on the same language used to write the requirements---the same language that the developers speak with each other and with domain experts.\"\n\n> \"The UBIQUITOUS LANGUAGE carries knowledge in a dynamic form.\"\n\n> \"Persistent use of the UBIQUITOUS LANGUAGE will force the model's weaknesses into the open. The team will experiment and find alternatives to awkward terms or combinations. As gaps are found in the language, new words will enter the discussion.\"\n\n**Bounded Context**\n\n> \"A defined part of software where particular terms, definitions and rules apply in a consistent way.\"\n\nEvans explained at DDD Europe 2019: \"Bounded context is basically a boundary where we eliminate any kind of ambiguity. It is a part of the software where particular terms, definitions, and rules apply in a consistent way.\"\n\nThe original purpose for a Bounded Context was to recognize that the development environment is messy---with legacy systems, external integrations, and other teams that may interfere. The context surrounds a part of software in which you have conceptual consistency and where a particular word always means the same thing.\n\n**DDD Summary (2014)**\n\nEvans later distilled the essence:\n\n> \"Domain-Driven Design is an approach to the development of complex software in which we: (1) Focus on the core domain; (2) Explore models in a creative collaboration of domain practitioners and software practitioners; (3) Speak a ubiquitous language within an explicitly bounded context.\"\n\n---\n\n## Architecture Patterns\n\n### Foote, Brian & Yoder, Joseph (1997/1999)\n\n**Big Ball of Mud**\n\n- **Authors:** Brian Foote, Joseph Yoder\n- **Affiliation:** Department of Computer Science, University of Illinois at Urbana-Champaign\n- **Original Presentation:** Fourth Conference on Patterns Languages of Programs (PLoP '97), Monticello, Illinois, September 1997\n- **Technical Report:** WUCS-97-34, Department of Computer Science, Washington University\n- **Published:** Chapter 29 in *Pattern Languages of Program Design 4* (Addison-Wesley, 2000)\n- **Last Updated:** June 26, 1999\n- **URL:** https://www.laputan.org/mud/\n\n#### Definition\n\n> \"A BIG BALL OF MUD is a casually, even haphazardly, structured system. Its organization, if one can call it that, is dictated more by expediency than design.\"\n\n> \"A BIG BALL OF MUD is haphazardly structured, sprawling, sloppy, duct-tape and bailing wire, spaghetti code jungle.\"\n\n#### Key Insight\n\nThe paper examines \"the most frequently deployed software architecture\"---acknowledging that while much attention focuses on high-level architectural patterns, the de-facto standard is seldom discussed. The paper explores \"the forces that encourage the emergence of a BIG BALL OF MUD, and the undeniable effectiveness of this approach to software architecture.\"\n\n> \"Architecture has been undervalued for so long that many engineers regard life with a BIG BALL OF MUD as normal.\"\n\nThe term \"Big Ball of Mud\" was coined by Brian Marick and popularized by Foote and Yoder's paper.\n\n#### Publication History\n\n| Date | Venue |\n|------|-------|\n| September 1997 | PLoP '97 Conference |\n| 1997 | Washington University Technical Report WUCS-97-34 |\n| June 1999 | Final revision |\n| December 1999 | Pattern Languages of Program Design 4 (Chapter 29) |\n\n### Harrison, Neil; Foote, Brian; Rohnert, Hans, eds. (1999)\n\n**Pattern Languages of Program Design 4**\n\n- **Editors:** Neil Harrison, Brian Foote, Hans Rohnert\n- **Publisher:** Addison-Wesley Professional\n- **Publication Date:** December 23, 1999\n- **ISBN-10:** 0201433044\n- **ISBN-13:** 978-0201433043\n- **Series:** Software Patterns Series\n\nContains the published version of \"Big Ball of Mud\" as Chapter 29.\n\n---\n\n### Cockburn, Alistair (2005)\n\n**Hexagonal Architecture (Ports and Adapters)**\n\n- **Author:** Dr. Alistair Cockburn\n- **Original Publication:** September 4, 2005\n- **URL:** https://alistair.cockburn.us/hexagonal-architecture/\n- **Also known as:** Ports and Adapters Architecture\n\n#### Intent\n\n> \"Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases.\"\n\n#### Core Demand\n\n> \"Create your application to work without either a UI or a database so you can run automated regression-tests against it, change connected technologies, protect it from leaks between business logic and technologies, work when the database becomes unavailable, and link applications together without any user involvement.\"\n\n#### History\n\nCockburn started teaching this concept in 1994 and discussing it publicly in 1998. The pattern was first discussed on Ward Cunningham's Portland Pattern Repository wiki. On July 25, 2005, Kevin Rutherford noted: \"Last month Alistair began using a new name for the Hexagonal Architecture pattern---he now calls it the Ports and Adapters Architecture.\" By September 2005, Cockburn had assembled the complete pattern and published the canonical article.\n\nThe hexagon shape was chosen not to suggest six ports, but to provide enough visual space to represent the different interfaces needed between the application and the external world.\n\nAround 2012, the Domain-Driven Design community adopted the pattern to isolate domain models from technology concerns.\n\n### Cockburn, Alistair & Garrido de Paz, Juan Manuel (2024)\n\n**Hexagonal Architecture Explained: How the Ports & Adapters Architecture Simplifies Your Life, and How to Implement It**\n\n- **Authors:** Dr. Alistair Cockburn, Juan Manuel Garrido de Paz\n- **Publisher:** Humans and Technology Inc\n- **Publication Date:** May 8, 2024\n- **ISBN-10:** 173751978X\n- **ISBN-13:** 978-1737519782\n- **Pages:** 202\n- **Updated Edition ISBN:** 979-8-9985862-0-0\n\nThe definitive book on Hexagonal Architecture by the pattern's creator. Provides detailed guidance on implementation, sample code, and answers to frequently asked questions.\n\nNote: Juan Manuel Garrido de Paz passed away unexpectedly in April 2024. Cockburn completed the book based on their collaboration, as they were within two weeks of finalizing the text at the time of Juan's passing.\n\n---\n\n### Martin, Robert C. (2012/2017)\n\n**Clean Architecture**\n\n#### Original Blog Post (2012)\n\n- **Author:** Robert C. Martin (\"Uncle Bob\")\n- **Title:** \"The Clean Architecture\"\n- **Publication Date:** August 13, 2012\n- **URL:** https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html\n\n#### Book (2017)\n\n**Clean Architecture: A Craftsman's Guide to Software Structure and Design**\n\n- **Author:** Robert C. Martin\n- **Publisher:** Pearson / Prentice Hall\n- **Publication Date:** September 10, 2017\n- **ISBN-10:** 0134494164\n- **ISBN-13:** 978-0134494166\n- **E-ISBN:** 978-0-13-449433-3\n- **Pages:** 432\n- **Series:** Robert C. Martin Series\n\n#### The Dependency Rule\n\n> \"The overriding rule that makes this architecture work is The Dependency Rule. This rule says that source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle.\"\n\n> \"The name of something declared in an outer circle must not be mentioned by the code in an inner circle. That includes, functions, classes, variables, or any other named software entity.\"\n\n> \"Data formats used in an outer circle should not be used by an inner circle, especially if those formats are generated by a framework in an outer circle. The goal is that nothing in an outer circle should impact the inner circles.\"\n\n#### Key Principles\n\nThe Dependency Rule always applies---source code dependencies point inward. As you move inward, abstraction increases. The outermost circle contains low-level concrete details. Inner circles encapsulate higher-level policies.\n\nDynamic polymorphism (interfaces) enables source code dependencies to oppose the flow of control, maintaining the Dependency Rule regardless of control flow direction.\n\n---\n\n## Related References (DDD & Architecture)\n\n### Martin Fowler on Bounded Context\n\n- **URL:** https://martinfowler.com/bliki/BoundedContext.html\n\n> \"Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD's strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.\"\n\n### Wikipedia Articles\n\n- Hexagonal Architecture: https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)\n- Domain-Driven Design: https://en.wikipedia.org/wiki/Domain-driven_design\n- Big Ball of Mud: https://en.wikipedia.org/wiki/Big_ball_of_mud\n\n---\n\n## SOLID Principles\n\n### Origin and Naming\n\n**Robert C. Martin, \"Design Principles and Design Patterns\"** (2000)\nObject Mentor white paper that introduced the five principles later named SOLID.\n\n> \"The symptoms of rotting design are familiar: Rigidity (hard to change), Fragility (breaks unexpectedly), Immobility (hard to reuse), Viscosity (doing things wrong is easier than doing things right).\"\n\nThe SOLID acronym was coined by Michael Feathers around 2004.\n\n---\n\n### Single Responsibility Principle (SRP)\n\n**Robert C. Martin, \"Agile Software Development: Principles, Patterns, and Practices\"** (Prentice Hall, 2002/2003), Chapter 8\n\n> \"A class should have only one reason to change.\"\n\nMartin credits the underlying concept to cohesion work by:\n\n- **Tom DeMarco, \"Structured Analysis and System Specification\"** (Yourdon Press, 1979)\n- **Meilir Page-Jones, \"The Practical Guide to Structured Systems Design\"** 2nd ed. (Yourdon Press, 1988)\n\nMartin clarified in a 2014 blog post:\n\n> \"Gather together the things that change for the same reasons. Separate those things that change for different reasons.\"\n\nSource: [The Single Responsibility Principle](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) (Clean Coder Blog)\n\n**Production Violations:**\n\n- **Android Context Class** (AOSP): God Object with 2000+ lines of javadoc, implements Service Locator pattern alongside multiple other responsibilities.\n- **Active Record Pattern**: Exposes two unrelated responsibilities (domain object behavior + data access CRUD).\n\n---\n\n### Open/Closed Principle (OCP)\n\n**Bertrand Meyer, \"Object-Oriented Software Construction\"** (Prentice Hall, 1st ed. 1988, 2nd ed. 1997)\n\n> \"A module should be open for extension but closed for modification.\"\n\nMeyer's definition: A module is *open* if it is available for extension (new functions and fields can be added). A module is *closed* if it is available for use by other modules (stable interface).\n\nThe book has over 7,300 citations (Google Scholar) and is foundational to OOP theory.\n\n**Polymorphic OCP**: In the 1990s, the principle was reinterpreted to emphasize abstracted interfaces with multiple implementations that can be substituted polymorphically. Detailed in:\n\n**Robert C. Martin, \"Agile Software Development: Principles, Patterns, and Practices\"** (2002), Chapter 9\n\n---\n\n### Liskov Substitution Principle (LSP)\n\n**Barbara Liskov, \"Data Abstraction and Hierarchy\"** Keynote Address, OOPSLA '87: Addendum to the Proceedings on Object-Oriented Programming Systems, Languages and Applications (October 1987)\n\n> \"If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2, then S is a subtype of T.\"\n\nPDF: [Tufts CS Archive](https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf)\n\n**Formal Definition (Behavioral Subtyping):**\n\n**Barbara Liskov and Jeannette Wing, \"A Behavioral Notion of Subtyping\"** ACM Transactions on Programming Languages and Systems (TOPLAS), Vol. 16, No. 6, pp. 1811-1841 (November 1994)\n\n- **DOI**: [10.1145/197320.197383](https://doi.org/10.1145/197320.197383)\n- **PDF**: [CMU Wing Publications](https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf)\n\nThis paper formalized the 1987 keynote into **strong behavioral subtyping**, including the treatment of aliasing. In a 2016 interview, Liskov explained that what she presented in 1987 was an \"informal rule,\" and Jeannette Wing later proposed they \"figure out precisely what this means.\"\n\n**The Square/Rectangle Problem:**\n\n**Robert C. Martin, \"The Liskov Substitution Principle\"** Engineering Notebook, C++ Report (March 1996)\n\n> \"A model, viewed in isolation, can not be meaningfully validated. The validity of a model can only be expressed in terms of its clients.\"\n\n> \"When the creation of a derived class causes changes to the base class, it often implies that the design is faulty and violates the Open-Closed principle.\"\n\nPDF: [UT Austin CS](https://www.cs.utexas.edu/~downing/papers/LSP-1996.pdf)\n\nKey insight: While Square is a mathematical specialization of Rectangle, it is not a *behavioral* subtype if Rectangle's contract allows independent width/height modification.\n\n**Design by Contract:**\n\n**Bertrand Meyer, \"Object-Oriented Software Construction\"** (1988/1997)\n\nMeyer coined \"Design by Contract\" and defined preconditions, postconditions, and invariants:\n\n> \"The stronger the precondition, the higher the burden on the client, and the easier for the contractor.\"\n\n---\n\n### Interface Segregation Principle (ISP)\n\n**Robert C. Martin, \"The Interface Segregation Principle\"** Engineering Notebook, C++ Report (August 1996)\n\n> \"Clients should not be forced to depend upon interfaces that they do not use.\"\n\n**Xerox Case Study (Origin):**\n\nThe ISP emerged from consulting work Martin did for Xerox on their new printer system:\n\n- A single `Job` class was used by almost all tasks (print, staple, fax)\n- This resulted in a \"fat\" class with methods specific to many different clients\n- Making modifications became increasingly difficult; even small changes required hour-long redeployment cycles\n\nThe solution used the Dependency Inversion Principle to add an interface layer with separate `Staple Job` and `Print Job` interfaces.\n\n**Production Violations:**\n\n- **NLog Framework (.NET)**: `NLogViewerTarget` derives from `TargetWithLayout` and must implement both getter and setter for `Layout` property, but doesn't need the setter. The workaround (ignoring the setter value) violates LSP.\n- **ATM Transaction Example**: Documented in \"Agile Software Development,\" Chapter 12.\n\n---\n\n### Dependency Inversion Principle (DIP)\n\n**Robert C. Martin, \"The Dependency Inversion Principle\"** Engineering Notebook, C++ Report (May 1996)\n\n> \"A. High level modules should not depend upon low level modules. Both should depend upon abstractions.\"\n> \"B. Abstractions should not depend upon details. Details should depend upon abstractions.\"\n\nPDF: [UT Austin CS](https://www.cs.utexas.edu/~downing/papers/DIP-1996.pdf)\n\nAlso detailed in:\n\n- **Robert C. Martin, \"Object Oriented Design Quality Metrics: an analysis of dependencies\"** (1994)\n- **Robert C. Martin, \"Agile Software Development: Principles, Patterns, and Practices\"** (2002), Chapter 11\n\n---\n\n### SOLID Bibliography Summary\n\n| Source | Author(s) | Year | Content |\n|--------|-----------|------|---------|\n| \"Design Principles and Design Patterns\" | Robert C. Martin | 2000 | Original white paper introducing the five principles |\n| \"Agile Software Development: Principles, Patterns, and Practices\" | Robert C. Martin | 2002 | Definitive SOLID treatment, Chapters 7-12 |\n| \"Object-Oriented Software Construction\" | Bertrand Meyer | 1988/1997 | OCP origin, Design by Contract |\n| \"Structured Analysis and System Specification\" | Tom DeMarco | 1979 | Cohesion concepts underlying SRP |\n| \"The Practical Guide to Structured Systems Design\" | Meilir Page-Jones | 1988 | Cohesion/coupling concepts |\n| \"Data Abstraction and Hierarchy\" | Barbara Liskov | 1987 | LSP origin (OOPSLA '87 keynote) |\n| \"A Behavioral Notion of Subtyping\" | Barbara Liskov, Jeannette Wing | 1994 | Formal LSP definition (ACM TOPLAS) |\n| \"The Liskov Substitution Principle\" | Robert C. Martin | 1996 | Square/Rectangle problem (C++ Report) |\n| \"The Interface Segregation Principle\" | Robert C. Martin | 1996 | ISP definition and Xerox case (C++ Report) |\n| \"The Dependency Inversion Principle\" | Robert C. Martin | 1996 | DIP definition (C++ Report) |\n\n**PDF Archives:**\n\n| Paper | URL |\n|-------|-----|\n| Martin C++ Report articles | [UT Austin CS](https://www.cs.utexas.edu/~downing/papers/) |\n| Liskov-Wing 1994 | [CMU Wing Publications](https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf) |\n| Liskov 1987 | [Tufts CS Archive](https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf) |\n\n**Research Studies:**\n\n**\"Applying the Single Responsibility Principle in Industry\"**\nProceedings of the 23rd International Conference on Evaluation and Assessment in Software Engineering (EASE 2019)\nIndustrial case study on two large-scale software systems (1,500+ classes) examining SRP violations.\nACM Digital Library: [doi.org/10.1145/3319008.3320125](https://dl.acm.org/doi/10.1145/3319008.3320125)\n\n**Microsoft Learn, \"Dangers of Violating SOLID Principles in C#\"** (MSDN Magazine, May 2014)\nDocuments how SOLID violations lead to code complexity, testing difficulty, merge conflicts, and coupling.\nSource: [Microsoft Learn Archive](https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/may/csharp-best-practices-dangers-of-violating-solid-principles-in-csharp)\n\n---\n\n## Thought Leaders\n\n### Donald Knuth\n\n**Agent**: `knuth` (algorithmic complexity)\n\n### Primary Source\n\nKnuth, Donald E. \"Structured Programming with go to Statements.\" *ACM Computing Surveys* 6, no. 4 (December 1974): 261-301.\n\n- **DOI**: [10.1145/356635.356640](https://doi.org/10.1145/356635.356640)\n- **Context**: Written in response to Dijkstra's \"Go To Statement Considered Harmful\" (1968), this paper argues for careful, measured use of goto statements in performance-critical code.\n\n### The Quote\n\n> \"There is no doubt that the grail of efficiency leads to abuse. Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: **premature optimization is the root of all evil**.\"\n\nThe quote continues:\n\n> \"Yet we should not pass up our opportunities in that critical 3%.\"\n\n### Attribution Note\n\nKnuth himself referred to this as \"Hoare's Dictum\" in \"The Errors of TeX\" (*Software--Practice & Experience* 19:7, July 1989, pp. 607-685). However, when asked, Tony Hoare suggested Dijkstra might deserve credit. The earliest traceable source remains this 1974 Knuth paper.\n\n### Application to Architecture\n\nThe Guild's `knuth` agent invokes this principle inversely: **architectural** complexity decisions are not premature optimization. The quote warns against micro-optimization of non-critical paths, not against understanding algorithmic complexity early. O(n) vs O(n^2) matters at design time. Loop unrolling can wait.\n\n---\n\n## Edsger W. Dijkstra\n\n**Agent**: `dijkstra` (formal correctness)\n\n### Primary Sources\n\n**The Humble Programmer** (1972)\n\nDijkstra, Edsger W. \"The Humble Programmer.\" *Communications of the ACM* 15, no. 10 (October 1972): 859-866.\n\n- **DOI**: [10.1145/355604.361591](https://doi.org/10.1145/355604.361591)\n- **EWD Archive**: [EWD340](https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html)\n- **Context**: ACM Turing Award lecture, delivered August 14, 1972, Boston.\n\n**How Do We Tell Truths That Might Hurt?** (1975)\n\nDijkstra, Edsger W. \"How do we tell truths that might hurt?\" EWD498, June 18, 1975.\n\n- **EWD Archive**: [EWD498](https://www.cs.utexas.edu/~EWD/transcriptions/EWD04xx/EWD498.html)\n- **Also in**: *Selected Writings on Computing: A Personal Perspective* (Springer, 1982).\n\n### The Quotes\n\n**On Abstraction** (used by `dijkstra` agent):\n\n> \"The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.\"\n\n*Note*: Sometimes rendered as \"The purpose of abstracting...\" The source is from Dijkstra's collection of aphorisms.\n\n**On Simplicity**:\n\n> \"Simplicity is prerequisite for reliability.\"\n\n**On the Programmer's Task** (from \"The Humble Programmer\"):\n\n> \"The competent programmer is fully aware of the strictly limited size of his own skull; he therefore approaches the programming task in full humility, and among other things he avoids clever tricks like the plague.\"\n\n**On Tools** (from EWD498):\n\n> \"The tools we use have a profound (and devious!) influence on our thinking habits, and, therefore, on our thinking abilities.\"\n\n### Application to Architecture\n\nThe Guild's `dijkstra` agent embodies his approach to correctness: preconditions, postconditions, invariants, and proof sketches. His emphasis on humility informs the agent's focus on formal verification rather than intuition. \"It seems to work\" is never sufficient.\n\n---\n\n## Leslie Lamport\n\n**Agent**: `lamport` (distributed systems)\n\n### Primary Sources\n\n**Time, Clocks, and the Ordering of Events in a Distributed System** (1978)\n\nLamport, Leslie. \"Time, Clocks, and the Ordering of Events in a Distributed System.\" *Communications of the ACM* 21, no. 7 (July 1978): 558-565.\n\n- **DOI**: [10.1145/359545.359563](https://doi.org/10.1145/359545.359563)\n- **Awards**: PODC Influential Paper Award (2000), ACM SIGOPS Hall of Fame Award (2007)\n- **Context**: One of the most cited papers in Computer Science. Introduced Lamport timestamps and the \"happened-before\" relation.\n\n**The Part-Time Parliament** (1998)\n\nLamport, Leslie. \"The Part-Time Parliament.\" *ACM Transactions on Computer Systems* 16, no. 2 (May 1998): 133-169.\n\n- **DOI**: [10.1145/279227.279229](https://doi.org/10.1145/279227.279229)\n- **PDF**: [lamport-paxos.pdf](https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf)\n- **Context**: First submitted in 1990. Describes the Paxos consensus algorithm through the allegory of a Greek parliament.\n\n**Paxos Made Simple** (2001)\n\nLamport, Leslie. \"Paxos Made Simple.\" *ACM SIGACT News* 32, no. 4 (December 2001): 18-25.\n\n- **PDF**: [paxos-simple.pdf](https://lamport.azurewebsites.net/pubs/paxos-simple.pdf)\n- **Context**: Plain-English explanation after the original paper's allegory proved difficult for readers.\n\n### Key Insight\n\nFrom \"Time, Clocks\":\n\n> \"The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events.\"\n\nThis partial ordering -- not total ordering -- is the fundamental insight. Distributed systems cannot have a global clock.\n\n### Application to Architecture\n\nThe Guild's `lamport` agent asks: \"What happens when the network lies? When clocks disagree?\" His work proves that local assumptions in distributed systems are mathematically invalid. The catchphrase \"Time is an illusion. Latency is real.\" captures Lamport's core insight: you cannot reason about distributed systems as if they were local.\n\n---\n\n## G.K. Chesterton\n\n**Agent**: `chesterton` (historical context)\n\n### Primary Source\n\nChesterton, Gilbert Keith. *The Thing: Why I Am a Catholic*. London: Sheed & Ward, 1929.\n\n- **Chapter**: \"The Drift from Domesticity\"\n- **Full text**: [Gutenberg](https://www.gutenberg.org/ebooks/author/80) (public domain)\n\n### The Quote\n\n> \"In the matter of reforming things, as distinct from deforming them, there is one plain and simple principle; a principle which will probably be called a paradox. There exists in such a case a certain institution or law; let us say, for the sake of simplicity, a fence or gate erected across a road. The more modern type of reformer goes gaily up to it and says, 'I don't see the use of this; let us clear it away.' To which the more intelligent type of reformer will do well to answer: 'If you don't see the use of it, I certainly won't let you clear it away. Go away and think. Then, when you can come back and tell me that you do see the use of it, I may allow you to destroy it.'\"\n\n### Common Paraphrase\n\n> \"Don't ever take a fence down until you know the reason it was put up.\"\n\nThis paraphrase was a favorite of John F. Kennedy (noted in *Bartlett's Familiar Quotations*).\n\n### Application to Architecture\n\nThe Guild's `chesterton` agent is the voice of historical context. Before removing \"dead\" code, understand why it exists. That mysterious `sleep(100)` might be a race condition fix. That \"unused\" module might be a production hotfix from 2019. The agent's process: `git blame`, commit messages, issue search, documentation -- understand the fence before removing it.\n\n---\n\n## Nassim Nicholas Taleb\n\n**Agent**: `taleb` (resilience and antifragility)\n\n### Primary Source\n\nTaleb, Nassim Nicholas. *Antifragile: Things That Gain from Disorder*. New York: Random House, 2012.\n\n- **ISBN**: 978-0-8129-7968-8 (paperback)\n- **Series**: Part of the *Incerto* series (includes *Fooled by Randomness*, *The Black Swan*, *Skin in the Game*)\n\n### Key Concepts\n\n**Antifragility**:\n\n> \"Some things benefit from shocks; they thrive and grow when exposed to volatility, randomness, disorder, and stressors and love adventure, risk, and uncertainty.\"\n\nThe book distinguishes three categories:\n\n| Category | Response to Stress |\n|----------|-------------------|\n| Fragile | Harmed by disorder |\n| Robust | Unaffected by disorder |\n| Antifragile | Gains from disorder |\n\n**Black Swan** (from *The Black Swan*, 2007):\n\nA high-impact, hard-to-predict event that is rationalized in hindsight. Software examples: cascade failures, security breaches, market crashes.\n\n### Application to Architecture\n\nThe Guild's `taleb` agent asks: \"What's the Black Swan? If AWS us-east-1 vanishes, does this degrade gracefully or explode?\" His framework shifts thinking from \"prevent all failures\" to \"benefit from stress.\" Systems should be antifragile where possible: circuit breakers that trip early, chaos engineering that strengthens, redundancy that exercises itself.\n\n---\n\n## Lotfi A. Zadeh\n\n**Agent**: `lotfi` (fuzzy scoring and trade-offs)\n\n### Primary Source\n\nZadeh, Lotfi A. \"Fuzzy Sets.\" *Information and Control* 8, no. 3 (June 1965): 338-353.\n\n- **DOI**: [10.1016/S0019-9958(65)90241-X](https://doi.org/10.1016/S0019-9958(65)90241-X)\n- **Publisher**: Academic Press\n\n### Key Concept\n\n> \"A fuzzy set is a class of objects with a continuum of grades of membership. Such a set is characterized by a membership (characteristic) function which assigns to each object a grade of membership ranging between zero and one.\"\n\nClassical set theory: an element is either in a set or not (binary). Fuzzy set theory: an element has a *degree* of membership (gradient).\n\n### Application to Architecture\n\nThe Guild's `lotfi` agent handles deadlocks between competing concerns. When `dijkstra` says BLOCK and `k` says APPROVE, binary verdicts fail. Fuzzy scoring enables nuanced trade-off analysis:\n\n- Consistency: 0.8\n- Availability: 0.3\n- Complexity: 0.6\n\nThis allows verdicts like \"acceptable for internal tools, not for payment processing\" -- degrees of truth, not binary choices.\n\n---\n\n## Foundational Software Engineering\n\n### David Parnas\n\n**Core Contribution**: Information hiding and module decomposition\n\n### Primary Source\n\nParnas, David L. \"On the Criteria To Be Used in Decomposing Systems into Modules.\" *Communications of the ACM* 15, no. 12 (December 1972): 1053-1058.\n\n- **DOI**: [10.1145/361598.361623](https://doi.org/10.1145/361598.361623)\n- **Affiliation**: Department of Computer Science, Carnegie-Mellon University\n- **Original Memo**: Written 1971 as Carnegie Mellon memo\n- **ACM Digital Library**: https://dl.acm.org/doi/10.1145/361598.361623\n\n### Key Quotes\n\n**On Module Decomposition**:\n\n> \"We have tried to demonstrate by these examples that it is almost always incorrect to begin the decomposition of a system into modules on the basis of a flowchart. We propose instead that one begins with a list of difficult design decisions or design decisions which are likely to change. Each module is then designed to hide such a decision from the others.\"\n\n**On Information Hiding**:\n\n> \"Every module in the second decomposition is characterized by its knowledge of a design decision which it hides from all others. Its interface or definition was chosen to reveal as little as possible about its inner workings.\"\n\n### Impact\n\nThree decades after Parnas first articulated information hiding, he argued it remains \"the most important and basic software design principle.\" In the 20th Anniversary edition of *The Mythical Man-Month*, Fred Brooks concludes: \"Parnas was right, and I was wrong about information hiding.\"\n\n### Application to Architecture\n\nModule boundaries should be drawn around design decisions likely to change, not around processing steps. This principle underpins interface design, encapsulation, and the separation of concerns that forms the foundation of modern software architecture.\n\n---\n\n### Alan Kay\n\n**Core Contribution**: Object-oriented programming, Smalltalk, personal computing\n\n### Recognition\n\nKay, Alan C. ACM A.M. Turing Award, 2003.\n\n- **Citation**: \"For pioneering many of the ideas at the root of contemporary object-oriented programming languages, leading the team that developed Smalltalk, and for fundamental contributions to personal computing.\"\n- **ACM Profile**: https://amturing.acm.org/award_winners/kay_3972189.cfm\n\n### Key Quotes\n\n**On Design Simplicity**:\n\n> \"Simple things should be simple, complex things should be possible.\"\n\n- **Origin**: Coined at Xerox PARC circa 1971 during discussions about children, end-users, user interfaces, and programming languages. Kay confirmed the origin in a September 17, 1998 email to Peter W. Lount.\n- **Context**: Emerged from Smalltalk design philosophy -- the language needed to work intuitively for children and end-users while remaining powerful enough that the entire system could be written in itself.\n\n**On Inventing the Future**:\n\n> \"The best way to predict the future is to invent it.\"\n\n- **Origin**: Spoken at Xerox PARC in 1971 during a meeting with Xerox executives. Kay stated: \"In a fit of passion I uttered the quote!\"\n- **Note**: Similar sentiments appear in Dennis Gabor's *Inventing the Future* (1963): \"The future cannot be predicted, but futures can be invented.\"\n\n### Smalltalk Contributions\n\nSmalltalk was the first complete dynamic object-oriented programming language and development environment. At Xerox PARC, Kay led development and coined the term \"object-oriented.\" The visual programming environment, revolutionary at the time, is now conventional. Overlapping screen windows, a component of the graphical user interface, emerged from Kay's \"user-centered\" approach to computing.\n\n### Application to Architecture\n\nKay's design philosophy -- simplicity for the common case, power for the edge case -- informs API design and system interfaces. The layered disclosure model (simple surface, complex depths) appears throughout well-designed systems.\n\n---\n\n### Andrew Hunt & David Thomas\n\n**Core Contribution**: Pragmatic software development principles, DRY, orthogonality\n\n### Primary Sources\n\n**First Edition** (1999):\n\nHunt, Andrew, and David Thomas. *The Pragmatic Programmer: From Journeyman to Master*. Reading, MA: Addison-Wesley, 1999.\n\n- **ISBN-10**: 020161622X\n- **ISBN-13**: 978-0201616224\n- **Publisher**: Addison-Wesley Professional\n\n**Second Edition** (2019):\n\nThomas, David, and Andrew Hunt. *The Pragmatic Programmer: Your Journey to Mastery* (20th Anniversary Edition). Boston: Addison-Wesley, 2019.\n\n- **ISBN-10**: 0135957052\n- **ISBN-13**: 978-0135957059\n- **Pages**: 352\n- **Publisher**: Addison-Wesley Professional (by arrangement with The Pragmatic Bookshelf)\n\n### Key Concepts\n\n**DRY (Don't Repeat Yourself)**:\n\n> \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.\"\n\n- **Location**: Chapter 2, \"A Pragmatic Approach,\" Topic 9: \"DRY: The Evils of Duplication\"\n- **Scope**: Applies broadly to database schemas, test plans, build systems, and documentation -- not just code.\n\n**Orthogonality**:\n\n> \"Eliminate Effects Between Unrelated Things\" (Tip 13)\n\nTwo or more things are orthogonal if changes in one do not affect any of the others. Components should be self-contained, independent, and have a single, well-defined purpose. Combined with DRY, orthogonality produces systems that are more flexible, understandable, and easier to debug, test, and maintain.\n\n### Other Named Concepts\n\nThe book named or popularized several practices including rubber duck debugging and the broken windows theory applied to software.\n\n### Application to Architecture\n\nDRY and orthogonality are foundational architectural principles. DRY prevents knowledge fragmentation and inconsistency. Orthogonality ensures that changes remain localized, reducing blast radius and cognitive load. Together they form the basis for maintainable system design.\n\n---\n\n### Frederick P. Brooks Jr.\n\n**Core Contribution**: Software project management, Brooks' Law, essential vs. accidental complexity\n\n### Primary Sources\n\n**The Book**:\n\nBrooks, Frederick P., Jr. *The Mythical Man-Month: Essays on Software Engineering*. Reading, MA: Addison-Wesley, 1975.\n\n- **Anniversary Edition** (1995): Addison-Wesley, ISBN 0-201-83595-9\n- **ACM Reference**: https://dl.acm.org/doi/10.5555/207583\n\n**The Essay**:\n\nBrooks, Frederick P., Jr. \"No Silver Bullet -- Essence and Accident in Software Engineering.\" *Computer* 20, no. 4 (April 1987): 10-19.\n\n- **Original Presentation**: IFIP Congress, 1986\n- **Reprinted in**: Anniversary Edition of *The Mythical Man-Month* (1995)\n- **PDF**: https://worrydream.com/refs/Brooks_1986_-_No_Silver_Bullet.pdf\n\n### Brooks' Law\n\n> \"Adding manpower to a late software project makes it later.\"\n\nBrooks developed this observation from his experience managing IBM's OS/360 development. When the project fell behind, he added more programmers -- a decision he later concluded had delayed the project further.\n\n**Contributing factors**:\n1. **Ramp-up time**: New people must be educated about existing work, diverting resources from production\n2. **Communication overhead**: Channels increase with the square of people; doubling the team quadruples coordination complexity\n3. **Limited divisibility**: \"While it takes one woman nine months to make one baby, nine women can't make a baby in one month\"\n\nBrooks called this an \"outrageous oversimplification\" but one that captures the general rule.\n\n### Essential vs. Accidental Complexity\n\nFrom \"No Silver Bullet,\" following Aristotle:\n\n- **Essential complexity**: Inherent in the nature of the problem. If users want 30 features, those 30 features are essential. Nothing can remove it.\n- **Accidental complexity**: Self-inflicted difficulties that are not inherent to the problem. Engineers create it; engineers can fix it.\n\n> \"The complexity of software is an essential property, not an accidental one. Hence descriptions of a software entity that abstract away its complexity often abstract away its essence.\"\n\n**The thesis**: High-level languages reduced accidental complexity substantially. Today's programmers spend most of their time on essential complexity. Therefore, eliminating remaining accidental complexity cannot yield order-of-magnitude improvements.\n\n> \"But, as we look to the horizon of a decade hence, we see no silver bullet. There is no single development, in either technology or management technique, which by itself promises even one order of magnitude improvement in productivity, in reliability, in simplicity.\"\n\n### Later Reflection\n\nIn \"'No Silver Bullet' Refired\" (1995): \"It is my opinion, and that is all, that the accidental or representational part of the work is now down to about half or less of the total.\"\n\n### Application to Architecture\n\nBrooks' framework distinguishes problems worth solving (accidental complexity) from problems that must be managed (essential complexity). Architectural decisions should target accidental complexity -- unnecessary coupling, poor abstractions, technology mismatches -- while accepting that essential complexity cannot be designed away, only organized well.\n\n---\n\n# Event-Driven Architecture Patterns\n\nAuthoritative references for event-driven patterns documented in `skills/architecture/references/event-driven.md`.\n\n---\n\n## Command Query Separation (CQS)\n\n### Original Source\n\nMeyer, Bertrand. *Object-Oriented Software Construction*. Prentice Hall, 1988. Second edition, 1997.\n\n- **ISBN**: 978-0-13-629155-8 (2nd ed.)\n- **Publisher**: Prentice Hall PTR\n- **Context**: Bertrand Meyer developed CQS as part of his work on the Eiffel programming language. The book is one of the most influential OO books of the early OO era.\n\n### The Principle\n\nEvery method should either be a **command** that performs an action, or a **query** that returns data to the caller, but not both.\n\n> \"Asking a question should not change the answer.\"\n\n- **Queries**: Return a result and do not change the observable state of the system (free of side effects)\n- **Commands**: Change the state of a system but do not return a value\n\n### Acknowledged Exception\n\nMeyer himself noted that `pop()` on a stack is a useful idiom that violates CQS -- a query that modifies state. Practical pragmatism over dogmatic purity.\n\n### Why This Matters\n\nCQS is the intellectual foundation for CQRS. Understanding Meyer's original principle clarifies what Greg Young generalized to the architectural level.\n\n---\n\n## CQRS (Command Query Responsibility Segregation)\n\n### Original Source\n\nYoung, Greg. \"CQRS Documents.\" November 2010.\n\n- **Primary PDF**: [cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)\n- **Alternative**: [cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf](https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf)\n- **E-book version**: [github.com/keyvanakbary/cqrs-documents](https://github.com/keyvanakbary/cqrs-documents)\n- **Context**: Originally a class manual, this document comprehensively covers CQRS, Event Sourcing, and related patterns.\n\n### The Definition\n\n> \"CQRS is simply the creation of two objects where there was previously only one.\"\n\nFrom a 2010 post titled \"CQRS, Task Based UIs, Event Sourcing agh!\"\n\n### Historical Context\n\nCQRS was originally considered just an extension of Meyer's CQS. For a long time it was discussed as \"CQS at a higher level.\" Eventually, after much confusion between the two concepts, it was correctly deemed to be a different pattern.\n\n### Secondary Source\n\nFowler, Martin. \"CQRS.\" *martinfowler.com*, July 14, 2011.\n\n- **URL**: [martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)\n- **Quote**: \"Greg Young was the first person I heard talking about this approach.\"\n- **Note**: Fowler also credits Udi Dahan as another advocate with detailed descriptions.\n\n### Greg Young on CQRS vs Event Sourcing (2016)\n\nFrom \"A Decade of DDD, CQRS, Event Sourcing\" talk:\n\n> \"You need to look at CQRS not as being the main thing. CQRS was a product of its time and meant to be a stepping stone towards the ideas of Event Sourcing.\"\n\n---\n\n## Event Sourcing\n\n### Original Naming\n\nFowler, Martin. \"Event Sourcing.\" *martinfowler.com*, December 12, 2005.\n\n- **URL**: [martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)\n- **Context**: Part of the \"Further Enterprise Application Architecture\" development writing. Remains in draft form but introduced the term and concept to wide audience.\n\n### The Definition\n\n> \"The fundamental idea of Event Sourcing is ensuring every change to the state of an application is captured in an event object, and that these event objects are themselves stored in the sequence they were applied for the same lifetime as the application state itself.\"\n\n### Greg Young's Elaboration\n\nGreg Young introduced Event Sourcing to the public around the same time as CQRS (2010). He uses the term Event Sourcing to mean \"the rebuilding of objects based on events.\"\n\n- **Source**: CQRS Documents (2010)\n- **EventStore**: Greg Young is the lead architect of Event Store, the purpose-built event sourcing database.\n\n### Key Distinction\n\n> \"CQRS is about isolating reads from writes into different code paths. Event Sourcing is about using events to record state.\"\n\nState transitions are modelled within the domain using events. Events are facts about what happened -- they are never updated or deleted, they are immutable.\n\n---\n\n## Saga Pattern\n\n### Original Source\n\nGarcia-Molina, Hector, and Kenneth Salem. \"Sagas.\" *Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data* (SIGMOD '87). San Francisco, CA, May 27-29, 1987, pp. 249-259.\n\n- **DOI**: [10.1145/38713.38742](https://doi.org/10.1145/38713.38742)\n- **ACM DL**: [dl.acm.org/doi/10.1145/38713.38742](https://dl.acm.org/doi/10.1145/38713.38742)\n- **Full PDF**: [cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf)\n- **Also in**: *ACM SIGMOD Record* 16, no. 3 (December 1987): 249-259.\n\n### The Problem\n\n> \"Long lived transactions (LLTs) hold on to database resources for relatively long periods of time, significantly delaying the termination of shorter and more common transactions.\"\n\n### The Solution\n\n> \"A LLT is a saga if it can be written as a sequence of transactions that can be interleaved with other transactions. The database management system guarantees that either all the transactions in a saga are successfully completed or compensating transactions are run to amend a partial execution.\"\n\n### Historical Note\n\nThe original paper was written for a **single relational database**, defining a way to handle system failures for long-running transactions. The microservices community adopted the same mechanism for distributed transactions, hence \"distributed sagas.\"\n\n### Key Insight\n\nSagas trade atomicity for progress. Instead of blocking other transactions while a long-lived transaction completes, sagas allow interleaving with compensating transactions to handle failures.\n\n---\n\n## Transactional Outbox Pattern\n\n### Primary Source\n\nRichardson, Chris. \"Pattern: Transactional Outbox.\" *microservices.io*.\n\n- **URL**: [microservices.io/patterns/data/transactional-outbox.html](https://microservices.io/patterns/data/transactional-outbox.html)\n- **Book**: Richardson, Chris. *Microservices Patterns: With Examples in Java*. Manning Publications, 2018. ISBN: 978-1-61729-454-9.\n- **Context**: Chris Richardson is the creator of the original CloudFoundry.com and author of *POJOs in Action*. He is the publisher of microservices.io.\n\n### The Problem\n\n> \"Without using 2PC, sending a message in the middle of a transaction is not reliable. There's no guarantee that the transaction will commit. Similarly, if a service sends a message after committing the transaction there's no guarantee that it won't crash before sending the message.\"\n\n### The Solution\n\n> \"A service command typically needs to create/update/delete aggregates in the database and send messages/events to a message broker... The command must atomically update the database and send messages in order to avoid data inconsistencies and bugs.\"\n\nThe pattern: Write the message to an OUTBOX table as part of the same database transaction. A separate message relay process publishes events from the outbox to the message broker.\n\n### Related Patterns\n\n- **Polling Publisher**: Poll the outbox table for unpublished messages\n- **Transaction Log Tailing**: Use CDC (Change Data Capture) to read from the transaction log\n\n### Udi Dahan's Contribution\n\nDahan, Udi. \"Reliable Messaging Without Distributed Transactions.\" Particular Software.\n\n- **Video**: [particular.net/videos/messaging-without-dtc](https://particular.net/videos/messaging-without-dtc)\n- **Context**: Explains the outbox pattern in depth, including implementation in NServiceBus.\n\nKey insight from Dahan: Use a table of message IDs for duplicate detection, and a table of outgoing messages for replay. If a message is a duplicate, replay the sending of all outgoing messages with the same message IDs so downstream subscribers' deduplication logic works correctly.\n\n---\n\n## Idempotency in Distributed Systems\n\n### Academic Foundation\n\nRamalingam, G., and Kapil Vaswani. \"Fault Tolerance via Idempotence.\" *Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages* (POPL '13). Rome, Italy, January 2013.\n\n- **DOI**: [10.1145/2429069.2429100](https://doi.org/10.1145/2429069.2429100)\n- **PDF**: [microsoft.com/en-us/research/wp-content/uploads/2016/02/popl38-ramalingam.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/popl38-ramalingam.pdf)\n- **Affiliation**: Microsoft Research\n\n### The Challenge\n\n> \"Writing applications for distributed systems is challenging because of the pitfalls of distribution such as process failures, communication failures, asynchrony and concurrency... One common requirement and challenge is the need for distributed applications that are idempotent.\"\n\n### The Definition\n\n> \"Idempotence ensures that the application functions correctly even when clients send duplicate requests, perhaps because the application failed to generate a response due to process failures, or because the response was generated but lost.\"\n\n### Practical Implementation\n\nHelland, Pat. \"Life beyond Distributed Transactions: an Apostate's Opinion.\" *CIDR 2007*, pp. 132-141.\n\n- **PDF**: [ics.uci.edu/~cs223/papers/cidr07p15.pdf](https://ics.uci.edu/~cs223/papers/cidr07p15.pdf)\n- **Republished**: *ACM Queue*, 2016. [queue.acm.org/detail.cfm?id=3025012](https://queue.acm.org/detail.cfm?id=3025012)\n- **About the Author**: Pat Helland has been implementing transaction systems, databases, distributed systems, and messaging systems since 1978. Currently at Salesforce.\n\n### Key Quote on Idempotency\n\n> \"Processing messages that are not naturally idempotent requires ensuring that each message is processed at most once (i.e., the substantive impact of the message must happen at most once).\"\n\nMessages that cause substantive changes are not naturally idempotent. The application must include mechanisms to ensure idempotence -- typically by remembering that the message has been processed.\n\n### The Activity Pattern\n\nHelland introduces \"Activity\" -- responsible for remembering the history of interactions. This history needs to answer: \"Did I process that message already?\"\n\n---\n\n## Message Delivery Semantics\n\n### The Three Guarantees\n\n| Guarantee | Definition | Trade-off |\n|-----------|------------|-----------|\n| **At Most Once** | Messages delivered 0 or 1 times | Lowest latency, risk of data loss |\n| **At Least Once** | Messages delivered 1 or more times | Guaranteed delivery, requires idempotent consumers |\n| **Exactly Once** | Messages delivered exactly 1 time | Requires idempotency + deduplication (effectively \"exactly once effect\") |\n\n### The Fundamental Problem\n\nTrue \"exactly once\" delivery is impossible in distributed systems due to the Two Generals Problem.\n\n### Original Paper on Two Generals\n\nAkkoyunlu, E.A., K. Ekanadham, and R.V. Huber. \"Some Constraints and Trade-offs in the Design of Network Communications.\" *Proceedings of the Fifth ACM Symposium on Operating Systems Principles* (SOSP '75). Austin, Texas, November 1975, pp. 67-74.\n\n- **DOI**: [10.1145/800213.806523](https://doi.org/10.1145/800213.806523)\n- **Context**: The problem was originally described using gangsters, not generals.\n\n### The Name\n\nGray, Jim. \"Notes on Data Base Operating Systems.\" In *Operating Systems: An Advanced Course*, Lecture Notes in Computer Science, vol 60. Springer, 1978, pp. 393-481.\n\n- **DOI**: [10.1007/3-540-08755-9_9](https://doi.org/10.1007/3-540-08755-9_9)\n- **Context**: Jim Gray named it the \"Two Generals Paradox\" in this 1978 paper.\n\n### Significance\n\n> \"The Two Generals' Problem was the first computer communication problem to be proven to be unsolvable.\"\n\nSystems achieve \"exactly once effect\" through at-least-once delivery combined with idempotent processing.\n\n---\n\n# Chaos Engineering\n\n**Related**: `plugins/arch-guild/skills/operations/references/chaos-patterns.md`\n\nChaos Engineering is the discipline of experimenting on a system in order to build confidence in the system's capability to withstand turbulent conditions in production. This bibliography traces its evolution from early fault injection research through Netflix's formalization to modern practice.\n\n---\n\n## Timeline of Chaos Engineering Evolution\n\n| Year | Event | Significance |\n|------|-------|--------------|\n| 1972 | Harlan Mills (IBM) proposes fault seeding | Earliest ancestor of software fault injection |\n| 1970s | Hardware fault injection emerges | HWIFI techniques for reliability testing |\n| 1990 | FIAT tool at Carnegie Mellon | Academic formalization of fault injection |\n| 1992 | FERRARI tool published | Software-based fault injection framework |\n| 1994 | FTAPE tool published | Fault tolerance measurement methodology |\n| 2006 | Google DiRT program founded | Disaster Recovery Testing at Google scale |\n| Early 2000s | Jesse Robbins creates GameDay at Amazon | First structured failure injection program |\n| 2008 | Netflix migrates to AWS | Database corruption triggers cloud move |\n| 2010 | Chaos Monkey created at Netflix | Greg Orzell and team build random termination tool |\n| July 2011 | Netflix Simian Army announced | Public debut of chaos engineering tools |\n| July 2012 | Chaos Monkey open-sourced | Apache 2.0 license on GitHub |\n| September 2012 | \"Resilience Engineering\" roundtable | ACM Queue article defining the practice |\n| February 2017 | Chaos Engineering arXiv paper | IEEE Software publication formalizes discipline |\n| 2017 | principlesofchaos.org launched | Canonical definition of principles |\n| 2020 | \"Chaos Engineering\" book (O'Reilly) | Comprehensive practitioner guide |\n\n---\n\n## Foundational Documents\n\n### The Principles of Chaos Engineering\n\n**Source**: principlesofchaos.org (Last updated: December 2017)\n\n**Authors**: Ali Basiri, Niosha Behnam, Ruud de Rooij, Lorin Hochstein, Luke Kosewski, Justin Reynolds, Casey Rosenthal\n\n**Key Definition**:\n\n> \"Chaos Engineering is the discipline of experimenting on a system in order to build confidence in the system's capability to withstand turbulent conditions in production.\"\n\n**The Four Steps**:\n\n1. Start by defining \"steady state\" as some measurable output of a system that indicates normal behavior\n2. Hypothesize that this steady state will continue in both the control group and the experimental group\n3. Introduce variables that reflect real-world events (servers crash, hard drives malfunction, network connections severed)\n4. Try to disprove the hypothesis by looking for a difference in steady state between control and experimental groups\n\n**Advanced Principles**:\n\n- Build a hypothesis around steady state behavior\n- Vary real-world events\n- Run experiments in production\n- Automate experiments to run continuously\n- Minimize blast radius\n\n**URL**: https://principlesofchaos.org/\n\n---\n\n### Chaos Engineering (arXiv)\n\nBasiri, Ali, Niosha Behnam, Ruud de Rooij, Lorin Hochstein, Luke Kosewski, Justin Reynolds, and Casey Rosenthal. \"Chaos Engineering.\" *IEEE Software* 34, no. 3 (May-June 2017): 35-41.\n\n- **arXiv**: [1702.05843](https://arxiv.org/abs/1702.05843) (submitted February 20, 2017)\n- **DOI**: 10.1109/MS.2017.55\n- **Citations**: 218+ (Semantic Scholar)\n\n**Abstract**:\n\n> \"Modern software-based services are implemented as distributed systems with complex behavior and failure modes. Many large tech organizations are using experimentation to verify the reliability of such systems. We use the term 'Chaos Engineering' to refer to this approach.\"\n\n**Context**: This paper formalized the discipline that Netflix engineers had been practicing since 2010, providing the academic foundation for chaos engineering as a field.\n\n---\n\n## Netflix Origins\n\n### The Netflix Simian Army (2011)\n\nIzrailevsky, Yury, and Ariel Tseitlin. \"The Netflix Simian Army.\" *Netflix Tech Blog*, July 19, 2011.\n\n- **Original URL**: http://techblog.netflix.com/2011/07/netflix-simian-army.html\n- **Medium Archive**: https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116\n\n**Key Quote**:\n\n> \"We have found that the best defense against major unexpected failures is to fail often. By frequently causing failures, we force our services to be built in a way that is more resilient.\"\n\n**The Flat Tire Analogy**:\n\n> \"Imagine getting a flat tire. Even if you have a spare tire in your trunk, do you know if it is inflated? Do you have the tools to change it? [...] Chaos Monkey is a tool that randomly disables our production instances to make sure we can survive this common type of failure without any customer impact.\"\n\n**The Name**:\n\n> \"The name comes from the idea of unleashing a wild monkey with a weapon in your data center (or cloud region) to randomly shoot down instances and chew through cables.\"\n\n---\n\n### Chaos Monkey Open Source Release (2012)\n\nBennett, Cory, and Ariel Tseitlin. \"Netflix Chaos Monkey Released into the Wild.\" *Netflix Tech Blog*, July 30, 2012.\n\n- **GitHub**: https://github.com/Netflix/chaosmonkey\n- **License**: Apache 2.0\n- **Original Repository**: https://github.com/Netflix/SimianArmy (archived)\n\n**Key Quote**:\n\n> \"We have found that the best defense against major unexpected failures is to fail often. By frequently causing failures, we force our services to be built in a way that is more resilient.\"\n\n---\n\n### The Simian Army Members\n\n| Tool | Purpose | First Announced |\n|------|---------|-----------------|\n| **Chaos Monkey** | Random instance termination | 2010 (internal), 2011 (public) |\n| **Latency Monkey** | Artificial delays in RESTful calls | 2011 |\n| **Conformity Monkey** | Find non-compliant instances | 2011 |\n| **Doctor Monkey** | Health checks, unhealthy instance removal | 2011 |\n| **Janitor Monkey** | Cleanup unused resources | 2011 |\n| **Security Monkey** | Find security violations | 2011 |\n| **Chaos Gorilla** | Kill entire availability zone | 2011 |\n| **Chaos Kong** | Kill entire region | Later addition |\n\n---\n\n## GameDay Origins\n\n### Jesse Robbins at Amazon\n\n**Creator**: Jesse Robbins (\"Master of Disaster\")\n\n**Context**: Robbins created GameDay at Amazon in the early 2000s while responsible for website availability for every Amazon-branded property.\n\n**Background**: Robbins trained as a firefighter and EMT, serving as a volunteer and Emergency Manager including deployment during Hurricane Katrina. He adapted emergency response principles to software systems.\n\n**Key Quote**:\n\n> \"The key to building resilient systems is accepting that failure happens. There's just no getting around it. That applies to the software discipline, as well as to the systems management and architectural disciplines. It also applies to managing people. It's only after you've accepted the reality that failure is inevitable that you can begin the journey toward a truly resilient system.\"\n\n**Recognition**: MIT Technology Review TR35 Award (2011) for \"transforming the way Web companies design and manage complex networks of servers and software.\"\n\n**Wikipedia**: https://en.wikipedia.org/wiki/Jesse_Robbins\n\n---\n\n### Resilience Engineering: Learning to Embrace Failure (2012)\n\nRobbins, Jesse, Kripa Krishnan, John Allspaw, and Thomas A. Limoncelli. \"Resilience Engineering: Learning to Embrace Failure.\" *ACM Queue* 10, no. 9 (September 2012): 20-28.\n\n- **URL**: https://queue.acm.org/detail.cfm?id=2371297\n- **Also in**: *Communications of the ACM* 55, no. 11 (November 2012): 40-47\n\n**Key Quote**:\n\n> \"At the core of every resilience program at companies like Google, Facebook, Etsy, Flickr, Yahoo, or Amazon is the understanding that when engineering systems at Internet scale, the best you can hope for is to build a reliable software platform on top of components that are completely unreliable, putting you in an environment where complex failures are both inevitable and unpredictable.\"\n\n**Participants**:\n- **Jesse Robbins**: Architect of GameDay at Amazon, \"Master of Disaster\"\n- **Kripa Krishnan**: Technical Program Manager, Google DiRT program\n- **John Allspaw**: VP Engineering at Etsy, co-author \"Web Operations\"\n- **Thomas A. Limoncelli**: Site Reliability Engineer at Google, moderator\n\n---\n\n## Google DiRT Program\n\n### Weathering the Unexpected (2012)\n\nKrishnan, Kripa. \"Weathering the Unexpected.\" *Communications of the ACM* 55, no. 11 (November 2012): 48-52.\n\n- **URL**: https://cacm.acm.org/magazines/2012/11/156583-weathering-the-unexpected/fulltext\n- **DOI**: 10.1145/2366316.2366332\n\n**Key Quote**:\n\n> \"The most important of those lessons is that an untested disaster recovery plan isn't really a plan at all.\"\n\n**About DiRT**:\n\nGoogle's DiRT (Disaster Recovery Testing) program was founded by site reliability engineers in 2006. DiRT intentionally instigates failures in critical technology systems and business processes to expose unaccounted-for risks.\n\n**Methodology**:\n\n> \"DiRT tests both Google's technical robustness, by breaking live systems, and our operational resilience by explicitly preventing critical personnel, area experts, and leaders from participating.\"\n\n**Evolution**:\n\n- Started with individual groups testing failure scenarios specific to their service\n- Progressed to simulating major outages (primary source-control management servers)\n- Eventually simulated major disasters (Bay Area \"earthquake\" taking down a data center)\n\n---\n\n### 10 Years of Crashing Google (2015)\n\nKrishnan, Kripa. \"10 Years of Crashing Google.\" USENIX LISA Conference, 2015.\n\n- **URL**: https://www.usenix.org/conference/lisa15/conference-program/presentation/krishnan\n\n**Context**: Retrospective on DiRT program evolution from 2006-2015.\n\n---\n\n## Books\n\n### Chaos Engineering: System Resiliency in Practice (2020)\n\nRosenthal, Casey, and Nora Jones, eds. *Chaos Engineering: System Resiliency in Practice*. Sebastopol, CA: O'Reilly Media, 2020.\n\n- **ISBN**: 978-1-4920-4386-7 (paperback)\n- **ISBN**: 978-1-4920-4385-0 (ebook)\n- **O'Reilly**: https://www.oreilly.com/library/view/chaos-engineering/9781492043850/\n\n**From the Introduction**:\n\n> \"The story begins at Netflix in 2008, when they made a public move from the datacenter to the cloud following a major database corruption event that left Netflix unable to ship DVDs for three days. The thinking at the time was that the datacenter locked them into an architecture of single points of failure, and moving to the cloud would necessitate horizontally scaled components to decrease these single points of failure.\"\n\n**About the Editors**:\n- **Casey Rosenthal**: CEO and cofounder of Verica; formerly engineering manager of Chaos Engineering Team at Netflix\n- **Nora Jones**: Cofounder and CEO of Jeli (acquired by PagerDuty 2023); formerly chaos engineer at Netflix and Slack\n\n**Chapter 5** covers Google DiRT in detail.\n\n---\n\n### Site Reliability Engineering: How Google Runs Production Systems (2016)\n\nBeyer, Betsy, Chris Jones, Jennifer Petoff, and Niall Richard Murphy, eds. *Site Reliability Engineering: How Google Runs Production Systems*. Sebastopol, CA: O'Reilly Media, 2016.\n\n- **ISBN**: 978-1-4919-2912-4 (paperback)\n- **ISBN**: 978-1-4919-2911-7 (ebook)\n- **Free online**: https://sre.google/sre-book/table-of-contents/\n\n**Relevant Chapters**:\n\n- **Chapter 17**: Testing for Reliability\n- **Chapter 18**: Software Engineering in SRE\n- **Chapter 28**: Accelerating SREs to On-Call and Beyond\n- **Part IV**: Management (incident response, postmortems)\n\n**Key Principle**:\n\n> \"Hope is not a strategy.\"\n\n---\n\n### Web Operations: Keeping the Data on Time (2010)\n\nAllspaw, John, and Jesse Robbins, eds. *Web Operations: Keeping the Data on Time*. Sebastopol, CA: O'Reilly Media, 2010.\n\n- **ISBN**: 978-1-4493-7744-1\n- **Published**: June 21, 2010\n- **O'Reilly**: https://www.oreilly.com/library/view/web-operations/9781449377465/\n\n**Context**: Pre-dates the term \"chaos engineering\" but establishes the operational mindset. Contributors include pioneers who would go on to shape chaos engineering and DevOps.\n\n**Notable Contributors**: Heather Champ, Richard Cook, Patrick Debois, Eric Ries, Theo Schlossnagle, Baron Schwartz, Andrew Shafer.\n\n---\n\n## Academic Fault Injection (Pre-Chaos)\n\n### FIAT: Fault Injection Automated Testing (1990)\n\nBarton, J.H., E.W. Czeck, Z.Z. Segall, and D.P. Siewiorek. \"Fault Injection Experiments Using FIAT.\" *IEEE Transactions on Computers* 39, no. 4 (April 1990): 575-582.\n\n- **DOI**: 10.1109/12.54842\n- **Institution**: Carnegie Mellon University\n\n**Context**: Academic foundation for software fault injection at Carnegie Mellon. D.P. Siewiorek's work established the theoretical framework that later tools would build upon.\n\n---\n\n### FERRARI: Fault and Error Automatic Real-time Injector (1992)\n\nKanawati, G.A., N.A. Kanawati, and J.A. Abraham. \"FERRARI: A Flexible Software-Based Fault and Error Injection System.\" *IEEE Transactions on Computers* 44, no. 2 (February 1995): 248-260.\n\n- **DOI**: 10.1109/12.364536\n- **Conference**: First presented at 22nd International Symposium on Fault-Tolerant Computing (1992)\n\n**Technique**: Software traps that inject errors into a system, activated by either a call to a specific memory location or a timeout.\n\n---\n\n### FTAPE: Fault Tolerance and Performance Evaluator (1994)\n\nTsai, Timothy K., and Ravishankar K. Iyer. \"FTAPE: A Fault Injection Tool to Measure Fault Tolerance.\" In *Dependable Computing - EDCC-1*, Lecture Notes in Computer Science, vol. 852. Springer, 1994.\n\n- **NASA Technical Report**: 19950018913\n- **Archive**: https://archive.org/details/nasa_techdoc_19950018913\n- **DOI**: 10.1007/BFb0024305\n\n**Components**:\n- System-wide fault injector\n- Workload generator\n- Workload activity measurement tool\n\n**Capability**: Could inject faults into memory, registers, and disk accesses -- more comprehensive than earlier tools.\n\n---\n\n## Related Work\n\n### Learning from Incidents\n\n**Founder**: Nora Jones (2019)\n\n**Purpose**: Open-sourcing and sharing learnings from incidents across organizations. Over 300 practitioners sharing new approaches to incident analysis.\n\n**Key Insight** (from Nora Jones):\n\n> \"Engineers don't read postmortems more often because they're usually not written very well, they don't help them become better engineers, and it takes time to write them well -- time people don't always have.\"\n\n---\n\n### Principles of Chaos Engineering (USENIX SREcon17)\n\nRosenthal, Casey. \"Principles of Chaos Engineering.\" USENIX SREcon17 Americas, San Francisco, March 2017.\n\n- **URL**: https://www.usenix.org/conference/srecon17americas/program/presentation/rosenthal\n\n**Context**: Conference talk that preceded the arXiv paper, presenting the principles to the SRE community.\n\n---\n\n# Alan Turing\n\n**Core Contribution**: Mathematical foundations of computation, computability theory, artificial intelligence. The ACM Turing Award is named in his honor.\n\n---\n\n## On Computable Numbers (1936)\n\n### Original Publication\n\nTuring, Alan M. \"On Computable Numbers, with an Application to the Entscheidungsproblem.\" *Proceedings of the London Mathematical Society*, Series 2, 42, no. 1 (1937): 230-265.\n\n- **DOI**: [10.1112/plms/s2-42.1.230](https://doi.org/10.1112/plms/s2-42.1.230)\n- **Received**: May 28, 1936\n- **Read**: November 12, 1936\n- **Published**: January 1, 1937\n- **PDF**: [cs.virginia.edu](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)\n\n### The Turing Machine\n\nThe paper introduced the theoretical model now called the \"Turing Machine\" — an abstract computing device with an infinite tape and a read/write head that can perform fundamental computational operations.\n\n> \"The 'computable' numbers may be described briefly as the real numbers whose expressions as a decimal are calculable by finite means.\"\n\n### The Entscheidungsproblem\n\nTuring proved that no algorithm can determine whether an arbitrary mathematical statement is true or false — resolving Hilbert's Entscheidungsproblem negatively.\n\n### The Halting Problem\n\nThe paper proved through diagonalization that it is impossible to construct a universal program that determines whether an arbitrary program will halt or loop indefinitely.\n\n### Church-Turing Thesis\n\nTuring's work established (independently of Alonzo Church) that all reasonable models of computation are equivalent in power.\n\n---\n\n## Computing Machinery and Intelligence (1950)\n\n### Original Publication\n\nTuring, Alan M. \"I.—Computing Machinery and Intelligence.\" *Mind*, LIX (59), no. 236 (October 1950): 433-460.\n\n- **DOI**: [10.1093/mind/LIX.236.433](https://doi.org/10.1093/mind/LIX.236.433)\n- **Publisher**: Oxford University Press\n- **Citations**: 6,000+\n\n### The Opening Question\n\n> \"I propose to consider the question, 'Can machines think?' This should begin with definitions of the meaning of the terms 'machine' and 'think'. The definitions might be framed so as to reflect so far as possible the normal use of the words, but this attitude is dangerous.\"\n\n### The Turing Test (Imitation Game)\n\nRather than asking \"Can machines think?\" (which he deemed ill-defined), Turing proposed an operational test: a judge communicates via text with two hidden entities (a human and a machine) and attempts to determine which is which.\n\n### Nine Objections\n\nTuring systematically addresses nine objections to machine thinking, including Lady Lovelace's Objection (\"machines can only do what we program them to\") and the Mathematical Objection (Gödel's incompleteness). His rebuttals remain philosophically relevant.\n\n---\n\n## Application to Architecture\n\n1. **Decidability**: Some problems are undecidable — architectures cannot \"solve\" certain classes of problems\n2. **Halting Problem in Practice**: Distributed systems inherit the halting problem — motivates timeouts, circuit breakers, graceful degradation\n3. **Church-Turing Thesis**: All Turing-complete models are equivalent in *capability* — tradeoffs are about efficiency, observability, and resilience, not power\n4. **Observable Behavior**: We cannot prove a component is \"correct\" internally; we can only verify observable behavior (contract-based testing, API versioning)\n\n---\n\n# Technology Strategy\n\nAuthoritative sources for economic and strategic thinking in software architecture. These inform **K**'s perspective: \"Does this pay rent? Cathedral vs shed?\"\n\n---\n\n## Conway's Law (1967/1968)\n\n### Original Publication\n\nConway, Melvin E. \"How Do Committees Invent?\" *Datamation* 14, no. 4 (April 1968): 28-31.\n\n- **URL**: [melconway.com](https://www.melconway.com/Home/Conways_Law.html)\n- **Original Submission**: 1967 (rejected by Harvard Business Review)\n- **Later Recognition**: Cited by Fred Brooks in *The Mythical Man-Month*\n\n### The Principle\n\n> \"Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.\"\n\n### Economic Insight\n\nOrganizational structure directly determines system architecture costs and flexibility. Teams cannot produce designs that contradict their communication patterns. This is not a guideline — it's a constraint.\n\n---\n\n## The Cathedral and the Bazaar (1997/1999)\n\n### Original Publication\n\nRaymond, Eric S. *The Cathedral and the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary*. Sebastopol, CA: O'Reilly Media, 1999.\n\n- **ISBN**: 978-1-56592-724-7\n- **Original Essay**: Presented at Linux Kongress, 1997\n- **License**: Open Publication License v2.0\n- **URL**: [catb.org](http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/)\n\n### Two Development Models\n\n| Model | Characteristics |\n|-------|-----------------|\n| **Cathedral** | Centralized, planned releases, small core team |\n| **Bazaar** | Distributed, continuous evolution, many contributors |\n\n### Linus's Law\n\n> \"Given enough eyeballs, all bugs are shallow.\"\n\nWith enough reviewers, every problem is transparent to someone.\n\n---\n\n## Technical Debt (1992)\n\n### Original Publication\n\nCunningham, Ward. \"The WyCash Portfolio Management System.\" *OOPSLA '92 Experience Report*, Addendum to Proceedings, March 1992.\n\n- **ACM DL**: [10.1145/157709.157715](https://doi.org/10.1145/157709.157715)\n- **URL**: [c2.com](https://c2.com/doc/oopsla92.html)\n- **Citations**: 799+\n\n### The Original Metaphor\n\n> \"Shipping first-time code is like going into debt. A little debt speeds development so long as it is paid back promptly with a rewrite... Objects make the cost of this transaction tolerable. The danger occurs when the debt is not repaid. Every minute spent on not-quite-right code counts as interest on that debt.\"\n\n### Common Misuse\n\nCunningham's metaphor was about *understanding* gaps, not *quality* gaps. He clarified in 2009: debt is code that reflects your understanding at the time, which later becomes outdated. \"Sloppy code\" isn't debt — it's just sloppy.\n\n---\n\n## Wardley Mapping (2005-2016)\n\n### Origin\n\nWardley, Simon. *Wardley Maps* (book). Available free at [learnwardleymapping.com](https://learnwardleymapping.com/book/).\n\n- **Creator**: Simon Wardley (developed at Fotango in 2005, refined at Canonical 2008-2010)\n- **Primary Resources**: [wardleymaps.com](https://wardleymaps.com/), Medium series (2016)\n\n### The Framework\n\nMaps technology components along two axes:\n- **Vertical (Y)**: Position in value chain (user need → underlying infrastructure)\n- **Horizontal (X)**: Evolution stage (Genesis → Custom Build → Product → Commodity)\n\n### Evolution Stages\n\n| Stage | Characteristics | Build/Buy |\n|-------|-----------------|-----------|\n| **Genesis** | Novel, poorly understood, high uncertainty | Build (if core) |\n| **Custom Build** | Bespoke solutions, emerging practices | Build |\n| **Product** | Feature competition, best practices | Evaluate |\n| **Commodity** | Utility, cost competition | Buy |\n\n### Strategic Principle\n\nBuild vs buy decisions should be based on component *maturity* and *differentiation*. Commodities should be bought; differentiating components in early evolution stages should be built.\n\n---\n\n## Joel Spolsky on Rewrites (2000)\n\n### Original Publication\n\nSpolsky, Joel. \"Things You Should Never Do, Part I.\" *Joel on Software*, April 6, 2000.\n\n- **URL**: [joelonsoftware.com](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/)\n\n### The Netscape Case\n\nNetscape rewrote their browser from 4.0 to 6.0. The rewrite took 3 years. During that time, competitors gained market share. The browser that shipped had bugs the old version had already fixed.\n\n### The Argument\n\n> \"It's important to remember that when you start from scratch there is absolutely no reason to believe that you are going to do a better job than you did the first time.\"\n\nOld code has accumulated bug fixes — each \"ugly\" line often represents a solved problem.\n\n### Caveat for AI Era\n\nThis advice was written when code generation was expensive. The calculus changes when AI can rewrite quickly — but the *knowledge* embedded in old code remains valuable.\n\n---\n\n## Quality Economics (2019)\n\n### Original Publication\n\nFowler, Martin. \"Is High Quality Software Worth the Cost?\" *martinfowler.com*, May 29, 2019.\n\n- **URL**: [martinfowler.com](https://martinfowler.com/articles/is-quality-worth-cost.html)\n\n### The Thesis\n\n> \"The 'cost' of high quality software is negative.\"\n\nHigher internal quality reduces \"cruft\" (code that's hard to work with), which directly reduces development velocity. Quality investment pays for itself through faster feature development.\n\n### Two Kinds of Quality\n\n| Quality Type | Definition | Visible To |\n|--------------|------------|------------|\n| **External** | Features, UI, performance | Users |\n| **Internal** | Code structure, maintainability | Developers |\n\nBoth matter economically. Internal quality compounds over time.\n\n---\n\n# Emerging Economics: AI and Software Development\n\n**Status**: Rapidly consolidating (2024-2025). These are emerging patterns, not established wisdom. Publication dates indicate field maturity.\n\n---\n\n## Productivity Research\n\n### GitHub Copilot Studies (2023-2024)\n\nGitHub Blog. \"Research: Quantifying GitHub Copilot's Impact on Developer Productivity and Happiness.\" 2024.\n\n- **URL**: [github.blog](https://github.blog/news-insights/research/research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/)\n\n**Key Finding**: Treatment group completed tasks 55.8% faster (1h 11m vs 2h 41m).\n\n**Caveat**: Microsoft research shows 11 weeks to fully realize benefits. Gains highest for routine tasks, not complex problem-solving.\n\n### Anthropic Economic Index (2025)\n\nAnthropic. \"Anthropic Economic Index.\" February 2025.\n\n- **URL**: [anthropic.com/economic-index](https://www.anthropic.com/economic-index)\n\n> \"Analysis of 100,000 Claude conversations finds AI reduces task time by 80% on average.\"\n\n**Macroeconomic Projection**: If universally adopted over 10 years, current models could increase US labor productivity growth by 1.8% annually.\n\n**Adoption Paradox**: 40% individual adoption vs 90% of firms report NOT using AI.\n\n---\n\n## The Build vs Buy Shift\n\n### Multiple Sources (2024-2025)\n\n- VentureBeat: \"Build vs buy is dead — AI just killed it\"\n- Silicon Valley Product Group: \"Build vs. Buy In The Age of AI\"\n\n**The Inversion**:\n\n> \"AI has made building accessible to everyone—what used to take weeks now takes hours, and what used to require fluency in a programming language now requires fluency in plain English.\"\n\n**New Calculus**: Build for differentiated, integrated, fast-changing workflows. Buy for commodities.\n\n**The CACE Principle**: \"Changing Anything Changes Everything\" — AI systems erode abstraction boundaries, creating entanglement.\n\n---\n\n## Technical Debt in AI Era\n\n### MIT Sloan Management Review (2024-2025)\n\n\"How to Manage Tech Debt in the AI Era.\" *MIT Sloan Management Review*.\n\n- **URL**: [sloanreview.mit.edu](https://sloanreview.mit.edu/article/how-to-manage-tech-debt-in-the-ai-era/)\n\n**Counterintuitive Finding**:\n\n> \"AI has significantly increased the real cost of carrying tech debt, as generative AI dramatically widens the gap in velocity between low-debt and high-debt coding.\"\n\nClean codebases compound with AI adoption. Messy codebases compound against you.\n\n---\n\n## Disposable Software Economics\n\n### The One-Shot App Phenomenon\n\nMultiple sources (2024-2025):\n- Code Conductor: \"Disposable AI Apps\"\n- UBOS: \"The Rise of Disposable Code\"\n\n**Definition**: Lightweight, single-purpose applications built rapidly for immediate use, then discarded.\n\n**Jevons' Paradox Applied**: As production cost decreases, consumption increases. Lower development costs → explosion of single-use software.\n\n---\n\n## Emerging Principles\n\n### What's Changing\n\n| Old Assumption | AI Challenge |\n|----------------|--------------|\n| Skill gaps require training | Capability bridging through tools |\n| Experience flattens with tools | Junior devs need fundamentals to benefit |\n| Technical debt is sunk cost | Debt is now competitive liability |\n| Design precedes coding | Design emerges from iteration |\n| Reusable software is always better | Disposable software is economically rational |\n\n### What's Timeless\n\n- Trade-offs exist — no free lunch\n- Conway's Law — org structure constrains design\n- Essential complexity cannot be eliminated, only organized\n- Computability limits remain (Turing)\n- Economic incentives drive behavior\n\n---\n\n## Verification Notes\n\nAll citations verified against:\n\n1. **ACM Digital Library** (DOI links tested)\n2. **Dijkstra Archive at UT Austin** (EWD transcriptions)\n3. **Microsoft Research** (Lamport papers, Ramalingam/Vaswani paper)\n4. **ScienceDirect** (Zadeh paper)\n5. **Publisher records** (Taleb, Chesterton, Hunt & Thomas, Brooks, Meyer, Richardson, Raymond)\n6. **Quote Investigator** (Alan Kay quote origins)\n7. **Cornell CS Archive** (Sagas paper PDF)\n8. **UCI ICS** (Helland paper PDF)\n9. **Martin Fowler's website** (Event Sourcing, CQRS articles, Quality Economics)\n10. **microservices.io** (Richardson patterns)\n11. **arXiv.org** (Chaos Engineering paper)\n12. **Netflix Tech Blog** (original Simian Army posts)\n13. **IEEE Xplore** (academic fault injection papers)\n14. **USENIX Archives** (conference presentations)\n15. **GitHub** (Netflix open source releases, Copilot research)\n16. **Proceedings of London Mathematical Society** (Turing 1936)\n17. **Oxford Academic / Mind Journal** (Turing 1950)\n18. **Datamation archives** (Conway's Law)\n19. **c2.com** (Ward Cunningham, Technical Debt)\n20. **Joel on Software** (Spolsky strategy articles)\n21. **Anthropic Economic Index** (Claude usage analysis)\n22. **MIT Sloan Management Review** (Technical debt in AI era)\n23. **VentureBeat, SVPG** (Build vs Buy analysis)\n24. **Wardley Maps community** (learnwardleymapping.com)\n\nLast verified: 2026-01-18\n"},{slug:"methodology",title:"Why The Guild Works",content:"# Why The Guild Works\n\nThe arch-guild is 13 reasoning agents that evaluate architecture decisions from orthogonal perspectives. This explains WHY it's designed this way.\n\n## The Problem: Architecture Reviews Fall Into Patterns\n\nArchitecture decisions need multiple perspectives. A caching decision involves economics (cost), consistency (distributed systems), security (DoS vectors), and capacity (memory bounds). Most reviews miss something because they come from one viewpoint.\n\nWhy this happens:\n\n**Tunnel vision.** The distributed systems expert sees consistency issues but misses the business value question. The security engineer sees attack vectors but misses the operational complexity cost.\n\n**Homogenization.** Multiple reviewers trained in the same school of thought converge on similar blind spots. If everyone learned \"always use microservices,\" nobody questions whether this service actually needs distribution.\n\n**Cognitive load.** Asking one person to hold seven competing perspectives simultaneously doesn't work. Working memory maxes out around four items (Cowan, 2001). Multi-perspective analysis requires multiple perspectives.\n\nThe Guild solves this by encoding perspectives into separate agents with enforced orthogonality locks. Each agent can only discuss their domain. This prevents homogenization and forces genuine perspective diversity.\n\n## Design Decision 1: Why 13 Agents?\n\nNot arbitrary. The structure is 7 Masters + 6 Specialists.\n\n### A 3-Minute Deliberation\n\nWhat does the guild actually produce? Here's a proposal passing through three agents:\n\n**Proposal**: \"Use in-memory HashMap for session cache\"\n\n**K** (Strategic): APPROVE with conditions — simplest solution, no infrastructure cost. Creates option value: easy to swap later if needs grow.\n\n**Lamport** (Distributed Reality): BLOCK — HashMap is per-process. With 4 replicas behind a load balancer, user hits replica A, session cached there, next request hits replica B — cache miss. Stale reads under any horizontal scaling.\n\n**Ixian** (Empiricist): \"Deploy to 1 replica first. Measure: P99 cache hit rate and stale read percentage over 48 hours. If hit rate > 95% and stale reads \u003C 1%, the single-instance assumption holds for now. If not, the data tells you when to migrate to Redis.\"\n\n**Result**: The human now knows HashMap works for single-instance but fails distributed. The decision is bounded: ship it for single-instance, with a measured trigger for migration.\n\nThree perspectives, three minutes, one informed decision. The human synthesizes — the guild doesn't decide for you.\n\n### 7 Masters (Always Active)\n\nThese agents review every architectural decision for broad coverage:\n\n- **K** (Strategic): Forces, constraints, optionality\n- **Karman** (Ontological): Does code match business reality?\n- **Burner** (Structural): Clean boundaries, dependency direction\n- **Lamport** (Temporal): Distributed systems, consistency, ordering\n- **Erlang** (Hydraulic): Capacity, backpressure, queueing\n- **Vector** (Adversarial): Attack surface, security\n- **Ace** (Psychocentric): Developer experience, cognitive friction\n\nWhy seven? These represent the fundamental dimensions that apply to almost every decision. You can't build distributed systems without Lamport's concerns. You can't build maintainable systems without Burner's concerns about boundaries. You can't build systems that developers will use correctly without Ace's perspective.\n\nSeven is small enough to be manageable (doesn't overwhelm with noise), large enough to catch most blind spots.\n\n### 6 Specialists (Context-Triggered)\n\nThese agents activate when specific conditions appear:\n\n- **Ixian** (Empirical): Always — mandatory post-consensus validation\n- **Dijkstra** (Deductive): Critical paths: auth, payments, state machines\n- **Knuth** (Complexity): Loops, aggregations, high-cardinality data\n- **Lotfi** (Fuzzy): Deadlocks between agents\n- **Taleb** (Antifragile): Production readiness, failure modes\n- **Chesterton** (Diachronic): Removing old code, legacy refactoring\n\nWhy specialists? Depth when needed, silence when not. Dijkstra's formal correctness perspective is essential for payment processing, unnecessary for marketing page layout. Knuth's algorithmic complexity analysis matters for search engines, not for CRUD endpoints.\n\nTriggering on context prevents noise. If every decision required complexity analysis, teams would tune out the signal.\n\n### Why Ixian Is Mandatory\n\nIxian closes every deliberation with validation criteria. This prevents open-loop decisions — decisions without feedback.\n\nResearch shows that teams without measurement frameworks celebrate failures and blame successes (Doran, 1981 on SMART goals; Kerr, 1975 on reward systems). The Guild can reason brilliantly about architecture and still be wrong. Ixian ensures we'll know if we were wrong.\n\n## Design Decision 2: Why Orthogonality Locks?\n\nEach agent has a defined domain and **cannot discuss topics outside it**. This is enforced in the system prompt.\n\nExample: K (Strategic) cannot discuss implementation correctness, security specifics, or performance details. If asked, K responds: \"That's outside my orthogonality lock. Burner/Vector/Knuth should assess that.\"\n\n### Why This Works\n\n**Prevents homogenization.** Without orthogonality locks, agents converge. Research on AI diversity shows g = -0.863 diversity reduction when AI agents are unconstrained (Lee et al., CHI 2025). Locks force genuine perspective diversity.\n\n**Forces synthesis.** The human must integrate perspectives. No single agent can claim \"comprehensive review.\" This keeps the human as the synthesizer, preventing dependency and preserving agency.\n\n**Enables depth.** Each agent can be maximally expert in one domain. Lamport doesn't need to hedge with \"I'm not a security expert, but...\" He stays in distributed systems and goes deep.\n\n**Makes disagreement meaningful.** When K says APPROVE and Lamport says BLOCK, it's not two people disagreeing about the same concern. It's strategic forces vs distributed systems physics — a genuine trade-off requiring human judgment.\n\n### Evidence: Control and Transparency\n\nCollaborative intelligence research identifies control (β = 0.507) and transparency (β = 0.415) as the strongest levers for effective human-AI collaboration (Blaurock et al., Journal of Service Research 2025, n=654).\n\nOrthogonality locks provide transparency: you know exactly what perspective you're getting. The human retains control: agents cannot override each other's domains, forcing the human to synthesize.\n\n## Design Decision 3: Why Drive/Scar/Nemesis?\n\nEach agent has three psychological motivators:\n\n- **Drive**: Core motivation (Strategic, Protective, Adversarial, Principled, Traumatic, Empirical)\n- **Scar**: Past experience that informs judgment (specific failure witnessed)\n- **Nemesis**: Anti-pattern they're vigilant against\n\nExample from Lamport:\n- **Drive**: Traumatic (experience)\n- **Scar**: Debugged split-brain at 3am, lost data due to \"it worked on my machine\"\n- **Nemesis**: The Local Assumption — pretending distributed systems are local\n\n### Why This Works\n\n**Consistent perspective.** The Drive/Scar/Nemesis framework gives agents a coherent identity that produces consistent reasoning. Lamport always thinks about network partitions because that's his scar.\n\n**Reduces hallucination.** Grounded in specific failure modes rather than generic \"distributed systems are hard.\" The scar provides concrete examples that anchor reasoning.\n\n**Enables prediction.** Users learn what agents will care about. After 3 decisions, you know Vector will flag untrusted input and Erlang will ask about backpressure. This builds trust.\n\n**Mimics expert behavior.** Real experts develop intuition from experience. The scar encodes that experience. Lamport's scar (split-brain debugging) mirrors Leslie Lamport's career spent formalizing distributed systems after witnessing their failures.\n\n## Design Decision 4: Why Named After Thought Leaders?\n\nAgents are named after the people whose work defines their domain:\n\n- **Lamport** → Leslie Lamport, \"Time, Clocks, and the Ordering of Events\" (1978)\n- **Dijkstra** → Edsger Dijkstra, \"The Humble Programmer\" (1972)\n- **Taleb** → Nassim Nicholas Taleb, *Antifragile* (2012)\n- **Knuth** → Donald Knuth, \"Premature optimization is the root of all evil\" (1974)\n\n### Why This Works\n\n**Intellectual lineage.** The names carry meaning. \"Lamport\" signals distributed systems expertise in a way \"DistributedSystemsAgent\" doesn't. The name evokes the body of work.\n\n**Prevents abstraction drift.** Generic names like \"ConsistencyChecker\" tend to drift. \"Lamport\" has a defined corpus of work that anchors the perspective.\n\n**Enables learning.** Users unfamiliar with distributed systems can read Lamport's papers to understand why the agent thinks this way. The name is a bibliography pointer.\n\n**Humility signal.** Naming agents after humans who spent decades in their domain signals that these perspectives come from hard-won experience, not LLM vibes.\n\n## Design Decision 5: Why Masters vs Specialists?\n\nWhy not just activate all 13 agents every time?\n\n**Noise reduction.** Not every decision needs every perspective. CRUD endpoints don't need Knuth's complexity analysis. Marketing pages don't need Dijkstra's formal correctness.\n\n**Attention budget.** Humans can only process so much input. Research shows 7 perspectives is near the limit before diminishing returns set in (Miller's \"magical number seven plus or minus two\").\n\n**Progressive disclosure.** Start with broad coverage (7 Masters), drill into specifics as context demands (6 Specialists). This matches how humans actually reason about problems.\n\n**Cost management.** Each agent invocation costs tokens. Triggering specialists only when needed reduces cost by approximately 40% compared to always-on 13 agents.\n\n### Trigger Conditions\n\nSpecialists have defined triggers in their `description` field:\n\n- **Ixian**: Always (mandatory post-consensus)\n- **Dijkstra**: Critical paths: auth, payments, state machines\n- **Knuth**: Loops, aggregations, recursive operations\n- **Lotfi**: Deadlocks between agents\n- **Taleb**: Production readiness, resilience review\n- **Chesterton**: Legacy refactoring, removing code > 2 years old\n\nThese triggers are intent-based, not keyword-based. The user says \"Is this ready for production?\" and Taleb activates because production readiness is his domain.\n\n## Design Decision 6: Why Mandatory Ixian at the End?\n\nIxian always closes deliberations with validation criteria. No decision is complete without answering: \"How do we know this worked?\"\n\n### Why This Matters\n\n**Prevents open-loop decisions.** Most architectural decisions are never validated. Teams make a choice, implement it, and move on. Nobody checks if it was right. The same mistakes repeat.\n\n**Forces testable hypotheses.** \"This will improve performance\" becomes \"P95 latency will drop below 200ms within 7 days.\" One is a hope, the other is falsifiable.\n\n**Enables compound learning.** The Guild Ratchet (`.claude/guild-ratchet.md`) captures validated learnings. Future decisions benefit from measured outcomes, not just opinions.\n\n**Counteracts confirmation bias.** Without validation criteria, teams interpret ambiguous outcomes as confirming their decision. Ixian forces specificity: what metric would prove us wrong?\n\n### Evidence: Learning from AI\n\nResearch on AI-assisted development shows that learning harm (17% worse exam performance after AI use) comes from skipping the validation step (Bastani et al., PNAS 2025). GPT Tutor (hints only) caused no harm. GPT Base (direct answers without validation) caused 17% harm.\n\nThe difference: GPT Tutor required learners to validate their understanding before proceeding. Ixian does this for architectural decisions.\n\n## Design Decision 7: How Agents Work Together\n\nThe Guild has a defined deliberation protocol:\n\n1. **Present** — State the decision/proposal clearly\n2. **Masters Evaluate** — Each provides verdict + rationale\n3. **Specialists Trigger** — Based on context flags\n4. **Surface Dissent** — Explicit disagreements noted\n5. **Ixian Closes** — Always, with validation criteria\n\n### Handling Deadlocks\n\nWhen agents conflict (e.g., K says APPROVE, Dijkstra says BLOCK), the Guild invokes **Lotfi** for fuzzy scoring.\n\nLotfi rates competing dimensions on 0.0-1.0 scales:\n\n- Consistency: 0.8\n- Availability: 0.3\n- Complexity: 0.6\n\nThis enables verdicts like \"acceptable for internal tools, not for payment processing.\" Degrees of truth, not binary yes/no.\n\n### Why Lotfi Exists\n\nBinary thinking forces false dichotomies. Zadeh's fuzzy set theory (1965) showed that real-world categories don't have sharp boundaries. Most architectural trade-offs are about degrees: \"How much consistency do we need? How much complexity can we tolerate?\"\n\nLotfi prevents deadlock without forcing false consensus.\n\n## The Ratchet: Compound Learning\n\nAfter significant decisions, the Guild captures learnings to `.claude/guild-ratchet.md`:\n\n```markdown\n## 2026-01-15: Redis vs HashMap Decision\n\n### Blocking Agents\n- Lamport: Per-instance HashMap breaks cache consistency with 4 replicas\n\n### Principle Extracted\n> \"In-memory caching requires single-writer architecture or accepting stale reads.\"\n\n### Future Trigger\nMulti-instance deployments with shared state\n```\n\nThe SessionStart hook loads this automatically. Future sessions benefit from past decisions.\n\n### Why This Works\n\n**Institutional memory.** Teams forget why decisions were made. The ratchet captures not just the decision, but the reasoning and validation.\n\n**Generalization.** The \"Principle Extracted\" generalizes the specific decision into a reusable insight. This compounds learning across decisions.\n\n**Pattern recognition.** Future proposals that match \"Future Trigger\" automatically reference the ratchet. You don't repeat analysis, you build on it.\n\n## What Makes This Collaborative Intelligence\n\nThe Guild is not \"AI does architecture reviews.\" It's a multi-agent system where humans and AI collaborate with defined roles:\n\n**Agents provide perspectives.** Each agent offers one viewpoint grounded in their domain expertise.\n\n**Humans synthesize.** The human integrates perspectives, makes trade-offs, and owns the final decision.\n\n**Agents amplify, don't replace.** The human doesn't need to remember all of Lamport's distributed systems research. The agent provides that perspective when needed.\n\n**Learning compounds.** Each interaction makes both human and system more capable. The human learns from agent reasoning. The ratchet captures validated outcomes.\n\n### Evidence: Complementary vs Substitutive\n\nResearch distinguishes complementary AI (amplifies human capability) from substitutive AI (replaces human work):\n\n| Substitutive | Complementary |\n|--------------|---------------|\n| AI decides, human approves | AI analyzes, human decides |\n| Human capability atrophies | Human capability compounds |\n| Trust becomes binary | Trust becomes calibrated |\n\nThe Guild is complementary by design. Agents cannot make decisions, only provide perspectives. Orthogonality locks prevent any single agent from claiming comprehensive review. The human remains central.\n\nEffect sizes: Complementary AI shows β = 0.507 for user control, β = 0.415 for transparency. Substitutive AI shows skill reduction (20% after 3 months, Lancet colonoscopy study).\n\n## Why This Matters for Software Quality\n\nThe Guild embodies principles from the Software Craftsmanship Manifesto:\n\n**Well-crafted software.** Multi-perspective review catches more issues than single-perspective review. Research on code review shows that perspective diversity correlates with bug detection (Rigby & Bird, ICSE 2013).\n\n**Steadily adding value.** The ratchet ensures decisions compound. Each validated principle makes future decisions faster and more accurate.\n\n**Community of professionals.** The agents are named after master craftsmen. Using the Guild means learning from Lamport, Dijkstra, Taleb — giants whose work spans decades.\n\n**Productive partnerships.** The human and agents collaborate. Neither is servant to the other. Different capabilities, shared goal: better architectural decisions.\n\n## When The Guild Fails\n\nThe Guild is not a silver bullet. It fails when:\n\n**Context is missing.** Agents can only reason about what they're told. If you don't mention \"we have 4 replicas,\" Lamport can't flag consistency issues.\n\n**Orthogonality is violated.** If users ask K for security advice, K will attempt it (despite the lock). The user must understand agent domains.\n\n**Validation is skipped.** Ixian provides criteria, but humans must measure. If validation criteria are ignored, the ratchet doesn't turn.\n\n**Trade-offs aren't made.** When K says APPROVE and Dijkstra says BLOCK, someone must decide. The Guild surfaces trade-offs, doesn't resolve them.\n\n## Who This Is For\n\nYou're an engineering lead with 30 minutes before an architecture review. You need to stress-test a proposal from multiple angles. The guild gives you 13 expert perspectives in those 30 minutes — perspectives that would normally require scheduling meetings with your security team, your distributed systems engineer, and your DX advocate.\n\nYou're not outsourcing judgment. You're expanding the surface area of your thinking.\n\n## The Bigger Picture\n\nThe Guild exists because architectural decisions are hard, multi-dimensional, and consequential. Getting them right requires perspectives most teams don't have in the room.\n\nTraditional approaches:\n- **Single architect**: Bottleneck, limited perspective\n- **Committee**: Slow, political, often converges on lowest common denominator\n- **Documentation**: Static, quickly outdated, doesn't adapt to context\n\nThe Guild provides on-demand, multi-perspective analysis that adapts to context, learns from outcomes, and preserves institutional memory.\n\nIt's not replacing architects. It's giving architects 13 expert consultants who never get tired, always remember past decisions, and focus on their domain without ego.\n\n## Next Steps\n\nTo understand the intellectual foundations of each agent's perspective:\n\n- Read `sources.md` for the complete bibliography (24 verified sources)\n- See `/references/guild-protocol.md` for the full agent specification\n- Check `../../../references/methodology.md` for the shared reasoning framework\n\nThe methodology explains HOW the agents work. This document explains WHY they're designed this way.\n"},{slug:"sources",title:"Intellectual Foundations: Key Sources",content:"# Intellectual Foundations: Key Sources\n\nThe arch-guild draws from foundational work in computer science, software engineering, and systems thinking. This document provides a curated overview of the key intellectual influences that shaped each agent's perspective.\n\n> **Note:** The complete bibliography with 24 verified sources, full citations, and DOI links exists at `bibliography.md` in this directory. This document highlights the essential readings for understanding WHY the Guild is designed this way.\n\n## The Thought Leaders\n\nEach agent is named after a person whose work defines their domain. Understanding the agent means understanding their namesake.\n\n### Leslie Lamport (1941–)\n\n**Agent**: `lamport` (temporal/distributed systems)\n\n**Core Contribution**: Formalized time and ordering in distributed systems\n\n**Essential Reading**:\n\nLamport, Leslie. \"Time, Clocks, and the Ordering of Events in a Distributed System.\" *Communications of the ACM* 21, no. 7 (July 1978): 558-565.\n\n- **DOI**: [10.1145/359545.359563](https://doi.org/10.1145/359545.359563)\n- **Why it matters**: Proved that distributed systems cannot have a global clock. The partial ordering of events — not total ordering — is fundamental. Every distributed system bug stems from violating this insight.\n\n**The Principle**:\n\n> \"A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable.\"\n\nLamport's work shows that local assumptions in distributed systems are mathematically invalid. You cannot reason about distributed systems as if they were local.\n\n---\n\n### Edsger Dijkstra (1930–2002)\n\n**Agent**: `dijkstra` (deductive/correctness)\n\n**Core Contribution**: Structured programming, algorithm correctness, intellectual humility\n\n**Essential Reading**:\n\nDijkstra, Edsger W. \"The Humble Programmer.\" *Communications of the ACM* 15, no. 10 (October 1972): 859-866.\n\n- **DOI**: [10.1145/355604.361591](https://doi.org/10.1145/355604.361591)\n- **Context**: ACM Turing Award lecture. Argues that programmers must approach their work with humility because complexity exceeds human cognitive capacity.\n\n**The Principles**:\n\n> \"The competent programmer is fully aware of the strictly limited size of his own skull; therefore he approaches the programming task in full humility.\"\n\n> \"The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.\"\n\n> \"Simplicity is prerequisite for reliability.\"\n\nDijkstra's emphasis on correctness through proof informs the agent's focus on preconditions, postconditions, and invariants. \"It seems to work\" is never sufficient.\n\n---\n\n### Donald Knuth (1938–)\n\n**Agent**: `knuth` (complexity/performance)\n\n**Core Contribution**: Algorithmic analysis, TeX, literate programming\n\n**Essential Reading**:\n\nKnuth, Donald E. \"Structured Programming with go to Statements.\" *ACM Computing Surveys* 6, no. 4 (December 1974): 261-301.\n\n- **DOI**: [10.1145/356635.356640](https://doi.org/10.1145/356635.356640)\n- **Why it matters**: Source of the famous quote on premature optimization. But the full context matters:\n\n**The Quote**:\n\n> \"We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.\"\n\nThe Guild's `knuth` agent applies this inversely: **architectural** complexity decisions are not premature optimization. O(n) vs O(n²) matters at design time. Loop unrolling can wait.\n\n---\n\n### Nassim Nicholas Taleb (1960–)\n\n**Agent**: `taleb` (antifragile/resilience)\n\n**Core Contribution**: Black swans, antifragility, skin in the game\n\n**Essential Reading**:\n\nTaleb, Nassim Nicholas. *Antifragile: Things That Gain from Disorder*. New York: Random House, 2012.\n\n- **ISBN**: 978-0-8129-7968-8\n\n**The Framework**:\n\n> \"Antifragility is beyond resilience or robustness. The resilient resists shocks and stays the same; the antifragile gets better.\"\n\nThree categories:\n\n| Category | Response to Stress |\n|----------|-------------------|\n| Fragile | Harmed by disorder |\n| Robust | Unaffected by disorder |\n| Antifragile | Gains from disorder |\n\nTaleb's insight shifts thinking from \"prevent all failures\" to \"benefit from stress.\" Systems should be antifragile where possible: circuit breakers that trip early strengthen the system by preventing cascades.\n\n---\n\n### Lotfi Zadeh (1921–2017)\n\n**Agent**: `lotfi` (fuzzy/trade-offs)\n\n**Core Contribution**: Fuzzy logic — real-world categories don't have sharp boundaries\n\n**Essential Reading**:\n\nZadeh, Lotfi A. \"Fuzzy Sets.\" *Information and Control* 8, no. 3 (June 1965): 338-353.\n\n- **DOI**: [10.1016/S0019-9958(65)90241-X](https://doi.org/10.1016/S0019-9958(65)90241-X)\n\n**The Insight**:\n\n> \"As complexity rises, precise statements lose meaning and meaningful statements lose precision.\"\n\nClassical set theory: an element is either in a set or not (binary). Fuzzy set theory: an element has a *degree* of membership (0.0 to 1.0).\n\nLotfi handles deadlocks between agents because binary verdicts fail when K says APPROVE and Dijkstra says BLOCK. Fuzzy scoring enables \"acceptable for internal tools (0.7), not for payment processing (0.2).\"\n\n---\n\n### G.K. Chesterton (1874–1936)\n\n**Agent**: `chesterton` (diachronic/legacy)\n\n**Core Contribution**: \"Chesterton's Fence\" — understand before removing\n\n**Essential Reading**:\n\nChesterton, Gilbert Keith. *The Thing: Why I Am a Catholic*. London: Sheed & Ward, 1929. Chapter: \"The Drift from Domesticity\"\n\n**The Principle**:\n\n> \"If you don't see the use of it, I certainly won't let you clear it away. Go away and think. Then, when you can come back and tell me that you do see the use of it, I may allow you to destroy it.\"\n\nApplied to software: That mysterious `sleep(100)` might be a race condition fix. That \"unused\" module might be a production hotfix from 2019. Before removing \"dead\" code, understand why it exists.\n\n---\n\n### Joe Armstrong (1950–2019)\n\n**Agent**: `erlang` (hydraulic/capacity)\n\n**Core Contribution**: Created Erlang, \"let it crash\" philosophy\n\n**The Principles**:\n\n> \"Only program the happy case. When the real world deviates from the specification, let it crash.\"\n\n> \"To make fault-tolerant systems you need TWO computers. You can never make a fault-tolerant system using just one.\"\n\nErlang powers 90% of internet traffic through telecom switches. The language's name inspired the agent, but the agent focuses on capacity and backpressure rather than fault isolation specifically.\n\n---\n\n## Foundational Architecture Patterns\n\nThe agents reference established architectural patterns with decades of validation.\n\n### Hexagonal Architecture (Ports and Adapters)\n\n**Source**: Alistair Cockburn (2005)\n\nCockburn, Alistair. \"Hexagonal Architecture.\" Published September 4, 2005.\n\n- **URL**: [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)\n- **Also known as**: Ports and Adapters Architecture\n\n**Intent**:\n\n> \"Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases.\"\n\nAround 2012, the Domain-Driven Design community adopted the pattern to isolate domain models from technology concerns. Referenced by **Burner** for boundary enforcement.\n\n---\n\n### Domain-Driven Design\n\n**Source**: Eric Evans (2003)\n\nEvans, Eric. *Domain-Driven Design: Tackling Complexity in the Heart of Software*. Addison-Wesley Professional, 2003.\n\n- **ISBN**: 978-0321125217\n- **Pages**: 560\n\n**Key Concepts**:\n\n**Ubiquitous Language**: The code must be based on the same language used to write requirements.\n\n**Bounded Context**: A boundary where terms, definitions, and rules apply consistently without ambiguity.\n\nReferenced by **Karman** for ontological modeling and **Burner** for boundary definition.\n\n---\n\n### Clean Architecture\n\n**Source**: Robert C. Martin (2012/2017)\n\nMartin, Robert C. \"The Clean Architecture.\" Blog post, August 13, 2012.\n\n- **URL**: [https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n\n**The Dependency Rule**:\n\n> \"Source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle.\"\n\nReferenced by **Burner** for dependency direction. The book (2017, ISBN 978-0134494166) expands the blog post into comprehensive guidance.\n\n---\n\n## Event-Driven Architecture\n\nThe Guild references foundational patterns for event-driven systems.\n\n### Command Query Responsibility Segregation (CQRS)\n\n**Source**: Greg Young (2010)\n\nYoung, Greg. \"CQRS Documents.\" November 2010.\n\n- **PDF**: [cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)\n\n**Definition**:\n\n> \"CQRS is simply the creation of two objects where there was previously only one.\"\n\nSeparates read models from write models. Built on Meyer's Command Query Separation (1988).\n\n---\n\n### Event Sourcing\n\n**Source**: Martin Fowler (2005)\n\nFowler, Martin. \"Event Sourcing.\" *martinfowler.com*, December 12, 2005.\n\n- **URL**: [martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)\n\n**Definition**:\n\n> \"Every change to the state of an application is captured in an event object, and these event objects are stored in the sequence they were applied.\"\n\nGreg Young elaborated: Event Sourcing means \"rebuilding objects based on events.\" State transitions are modeled as immutable events.\n\n---\n\n### Saga Pattern\n\n**Source**: Garcia-Molina & Salem (1987)\n\nGarcia-Molina, Hector, and Kenneth Salem. \"Sagas.\" *Proceedings of ACM SIGMOD* (1987): 249-259.\n\n- **DOI**: [10.1145/38713.38742](https://doi.org/10.1145/38713.38742)\n\n**The Problem**: Long-lived transactions hold database resources, delaying shorter transactions.\n\n**The Solution**: Break into a sequence of transactions that can be interleaved, with compensating transactions for partial failures.\n\nOriginally written for a single database; microservices community adopted it for distributed transactions.\n\n---\n\n## Chaos Engineering\n\nThe Guild references chaos engineering for resilience validation.\n\n### The Principles of Chaos Engineering\n\n**Source**: principlesofchaos.org (2017)\n\nAuthors: Ali Basiri, Niosha Behnam, Ruud de Rooij, Lorin Hochstein, Luke Kosewski, Justin Reynolds, Casey Rosenthal\n\n- **URL**: [https://principlesofchaos.org/](https://principlesofchaos.org/)\n\n**Definition**:\n\n> \"Chaos Engineering is the discipline of experimenting on a system in order to build confidence in the system's capability to withstand turbulent conditions in production.\"\n\n**The Four Steps**:\n\n1. Define steady state (measurable output indicating normal behavior)\n2. Hypothesize that steady state continues in control and experimental groups\n3. Introduce real-world variables (servers crash, network partitions)\n4. Try to disprove the hypothesis by finding differences\n\nReferenced by **Taleb** for antifragility and **Ixian** for validation methodology.\n\n---\n\n### Chaos Monkey (Netflix, 2010-2011)\n\n**Source**: Netflix Tech Blog (2011)\n\nIzrailevsky, Yury, and Ariel Tseitlin. \"The Netflix Simian Army.\" July 19, 2011.\n\n- **URL**: [netflixtechblog.com/the-netflix-simian-army-16e57fbab116](https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116)\n\n**The Insight**:\n\n> \"We have found that the best defense against major unexpected failures is to fail often. By frequently causing failures, we force our services to be built in a way that is more resilient.\"\n\nOpen-sourced in 2012 (GitHub: Netflix/chaosmonkey, Apache 2.0 license). Referenced by **Taleb** for stress-testing resilience.\n\n---\n\n## Strategic Thinking\n\nThe Guild integrates economic and strategic frameworks.\n\n### Conway's Law\n\n**Source**: Melvin Conway (1968)\n\nConway, Melvin E. \"How Do Committees Invent?\" *Datamation* 14, no. 4 (April 1968): 28-31.\n\n- **URL**: [melconway.com/Home/Conways_Law.html](https://www.melconway.com/Home/Conways_Law.html)\n\n**The Principle**:\n\n> \"Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.\"\n\nOrganizational structure directly determines system architecture. This is not a guideline — it's a constraint. Referenced by **K** for strategic force mapping.\n\n---\n\n### Technical Debt\n\n**Source**: Ward Cunningham (1992)\n\nCunningham, Ward. \"The WyCash Portfolio Management System.\" *OOPSLA '92 Experience Report*.\n\n- **DOI**: [10.1145/157709.157715](https://doi.org/10.1145/157709.157715)\n- **URL**: [c2.com/doc/oopsla92.html](https://c2.com/doc/oopsla92.html)\n\n**The Original Metaphor**:\n\n> \"Shipping first-time code is like going into debt. A little debt speeds development so long as it is paid back promptly with a rewrite.\"\n\nCunningham clarified in 2009: debt is code that reflects your understanding at the time, which later becomes outdated. \"Sloppy code\" isn't debt — it's just sloppy.\n\nReferenced by **K** for strategic force analysis.\n\n---\n\n### Wardley Mapping\n\n**Source**: Simon Wardley (2005-2016)\n\nWardley, Simon. *Wardley Maps*. Available free at [learnwardleymapping.com](https://learnwardleymapping.com/book/).\n\n**The Framework**: Maps technology components along two axes:\n\n- **Vertical**: Position in value chain (user need → infrastructure)\n- **Horizontal**: Evolution stage (Genesis → Custom Build → Product → Commodity)\n\n**Strategic Principle**: Build vs buy decisions should be based on component *maturity* and *differentiation*. Commodities should be bought; differentiating components in early evolution stages should be built.\n\nReferenced by **K** for build-vs-buy analysis.\n\n---\n\n## Software Craftsmanship\n\nThe Guild embodies principles from the software craftsmanship movement.\n\n### SOLID Principles\n\n**Source**: Robert C. Martin (1996-2003)\n\nOriginal papers published in *C++ Report* (1996), synthesized in:\n\nMartin, Robert C. *Agile Software Development: Principles, Patterns, and Practices*. Prentice Hall, 2002.\n\n- **ISBN**: 978-0135974445\n\n**The Five Principles**:\n\n- **Single Responsibility**: A class should have only one reason to change\n- **Open/Closed**: Open for extension, closed for modification (Bertrand Meyer, 1988)\n- **Liskov Substitution**: Subtypes must be substitutable (Barbara Liskov, 1987)\n- **Interface Segregation**: Don't force dependencies on unused interfaces\n- **Dependency Inversion**: Depend on abstractions, not concretions\n\nReferenced by **Burner** for structural analysis and **Karman** for abstraction quality.\n\n---\n\n### The Pragmatic Programmer\n\n**Source**: Andrew Hunt & David Thomas (1999/2019)\n\nHunt, Andrew, and David Thomas. *The Pragmatic Programmer* (20th Anniversary Edition). Addison-Wesley, 2019.\n\n- **ISBN**: 978-0135957059\n\n**Key Concepts**:\n\n**DRY (Don't Repeat Yourself)**:\n\n> \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.\"\n\n**Orthogonality**:\n\n> \"Eliminate Effects Between Unrelated Things.\"\n\nDRY prevents knowledge fragmentation. Orthogonality ensures changes remain localized. Together they form the basis for maintainable system design.\n\nReferenced by **Burner** for boundary analysis and the Guild's orthogonality lock design.\n\n---\n\n## Collaborative Intelligence Research\n\nThe Guild's design is grounded in research on human-AI collaboration.\n\n### Control and Transparency\n\n**Source**: Blaurock et al. (2025)\n\nBlaurock, M., Büttgen, M., & Schepers, J. \"Designing Collaborative Intelligence Systems for Employee-AI Service Co-Production.\" *Journal of Service Research* 28(4), 544-562. DOI: [10.1177/10946705241238751](https://journals.sagepub.com/doi/10.1177/10946705241238751).\n\n**Key Finding**: Process control (β = 0.507) and transparency (β = 0.415) are the strongest levers for effective human-AI collaboration. Engagement features backfire (b = -0.555). Two scenario-based experiments, N = 654 (not a meta-analysis). Effect sizes from full text, not independently verified from public sources.\n\n**Application**: Orthogonality locks provide transparency (you know what perspective you're getting). Human synthesis preserves control (no agent can override another's domain).\n\n---\n\n### Diversity Reduction Without Constraints\n\n**Source**: Lee et al. (2025)\n\nLee, Min Kyung, et al. \"The Impact of Generative AI on Critical Thinking.\" *CHI* (2025).\n\n**Key Finding**: AI confidence significantly predicts less critical thinking enacted (β = -0.69). Unconstrained AI systems reduce diversity (g = -0.863).\n\n**Application**: Orthogonality locks prevent homogenization by forcing agents to maintain distinct perspectives.\n\n---\n\n### Learning Harm from Unrestricted AI\n\n**Source**: Bastani et al. (2025)\n\nBastani, Hamsa, et al. \"Generative AI without guardrails can harm learning.\" *PNAS* (2025).\n\n**Key Finding**: Unrestricted ChatGPT use caused 17% worse exam performance. GPT Tutor (hints only) caused no harm. The difference: validation before proceeding.\n\n**Application**: Ixian's mandatory validation criteria force verification, preventing the \"answers without understanding\" problem.\n\n---\n\n## How to Use These Sources\n\n### For Understanding Agent Perspectives\n\nTo understand why an agent thinks a certain way, read their namesake's work:\n\n- **Lamport concerns**: Read \"Time, Clocks, and the Ordering of Events\"\n- **Dijkstra concerns**: Read \"The Humble Programmer\"\n- **Taleb concerns**: Read *Antifragile*\n\n### For Deepening Architectural Knowledge\n\nThe Guild references proven patterns:\n\n- **Boundaries**: Hexagonal Architecture (Cockburn), Clean Architecture (Martin)\n- **Domain modeling**: Domain-Driven Design (Evans)\n- **Event systems**: CQRS (Young), Event Sourcing (Fowler), Sagas (Garcia-Molina)\n\n### For Validating Guild Design\n\nThe collaborative intelligence research explains WHY the Guild works:\n\n- Control and transparency (Blaurock et al.)\n- Diversity preservation (Lee et al.)\n- Learning through validation (Bastani et al.)\n\n## The Complete Bibliography\n\nThis document highlights 20 essential sources. The complete bibliography with 24 verified sources, full citations, DOI links, and verification notes exists at:\n\n**Location**: `bibliography.md` (in this directory)\n\nAll citations verified against ACM Digital Library, IEEE Xplore, publisher records, and author websites as of 2026-01-18.\n\n---\n\n## Why These Sources Matter\n\nThe Guild isn't \"AI does architecture.\" It's a synthesis of decades of computer science research, encoded into reasoning agents with orthogonal perspectives.\n\nEach agent stands on the shoulders of giants. When Lamport flags a consistency issue, it's because Leslie Lamport spent his career formalizing distributed systems after witnessing their failures. When Dijkstra demands correctness, it's because Edsger Dijkstra watched critical systems fail from handwaving.\n\nThe sources aren't decorative. They're the foundation. Understanding them means understanding why the Guild's perspectives matter and when to trust (or override) their judgments.\n"}],"how-to":[],tutorials:[]},docCount:3}},uses:{params:["slug"]}}}(Array(5)))],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>

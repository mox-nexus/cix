# D2: When and How to Use It

D2 (Declarative Diagramming) for complex architecture diagrams when Mermaid isn't enough.

## THE Decision

**Default to Mermaid** (95% of cases). Only upgrade to D2 when:
- Complex architecture (50+ nodes) with poor Mermaid layout
- Precise positioning required for clarity
- Team willing to accept build step for better aesthetics
- Producing final diagrams for product documentation

**Trade-off**: D2 requires build step and pre-rendering. No native GitHub/GitLab rendering.

## When Mermaid Isn't Enough

| Issue with Mermaid | D2 Solution |
|-------------------|-------------|
| Auto-layout produces spaghetti | Multiple layout engines (dagre, ELK, TALA) |
| Limited styling control | CSS-like styling on elements |
| Poor positioning for complex diagrams | Better automatic positioning |
| Can't achieve specific layout | More control over grouping and hierarchy |

## D2 Strengths

**Natural nesting syntax**:
```d2
cloud: AWS {
  api: API Gateway {
    shape: rectangle
  }
  lambda: Lambda Functions {
    shape: cloud
  }
  db: RDS PostgreSQL {
    shape: cylinder
  }

  api -> lambda: invokes
  lambda -> db: queries
}
```

**Better layouts**: Dagre (fast), ELK (configurable), TALA (paid, best)

**Flexible styling**: Direct on elements, theme selection

**Systems focus**: Optimized for cloud architecture

## D2 vs Mermaid

### Mermaid
**Pros**: Zero build step, native GitHub/GitLab support, 20+ diagram types, instant preview, team adoption
**Cons**: Limited layout control, auto-layout can be messy, less styling flexibility

### D2
**Pros**: Superior auto-layout, natural nesting syntax, CSS-like styling, multiple layout engines
**Cons**: Build step required, no native GitHub/GitLab rendering, limited diagram variety

## D2 Setup

```bash
# macOS
brew install d2

# Linux
curl -fsSL https://d2lang.com/install.sh | sh

# Render to SVG
d2 architecture.d2 architecture.svg

# Specify layout engine
d2 --layout elk architecture.d2 architecture.svg

# Watch mode
d2 --watch architecture.d2 architecture.svg
```

## D2 Syntax Patterns

### Basic diagram
```d2
title: Microservices Architecture

api: API Gateway {
  style.fill: "#e3f2fd"
}
auth: Auth Service {
  style.fill: "#fff3e0"
}
db: PostgreSQL {
  shape: cylinder
  style.fill: "#f3e5f5"
}

api -> auth: authenticate
auth -> db: verify credentials
```

### Grouping
```d2
cloud: Production Environment {
  frontend: {
    web: React App
    mobile: Mobile App
  }
  backend: {
    api: API Server
    worker: Background Worker
  }
}
```

### Styling
```d2
service: My Service {
  shape: rectangle
  style.fill: "#2196f3"
  style.stroke: "#1976d2"
  style.font-color: white
  style.border-radius: 8
}
```

## Layout Engines

| Engine | When to Use | Trade-offs |
|--------|------------|------------|
| **dagre** (default) | Fast, simple diagrams | Unmaintained since 2018, non-optimal layouts |
| **elk** | Complex diagrams needing configuration | Can crash on large diagrams |
| **tala** | Best layouts | Paid (Terrastruct) |

## Workflow Integration

### GitHub/GitLab workflow
1. Create `.d2` source files
2. Render to SVG in CI/CD or locally
3. Commit both source and rendered images
4. Reference SVG in markdown: `![Architecture](./diagrams/architecture.svg)`

## When NOT to Use D2

- Quick documentation (Mermaid's instant rendering wins)
- Need Gantt, timeline, or mindmap (D2 doesn't support)
- Team collaboration without build setup
- GitHub/GitLab native rendering is critical

## Decision Checklist

Use D2 if ALL true:
- [ ] 50+ nodes or complex architecture
- [ ] Mermaid auto-layout produces poor results
- [ ] Build step acceptable
- [ ] Native GitHub rendering not required
- [ ] Need precise control over layout/styling

Otherwise, use Mermaid.

---

**Sources**: D2 official docs (d2lang.com), D2 vs Mermaid community discussions, production usage patterns
